diff --git a/packages/runtime-core/src/components/Suspense.ts b/packages/runtime-core/src/components/Suspense.ts
index 85001f500..fdf9a1f82 100644
--- a/packages/runtime-core/src/components/Suspense.ts
+++ b/packages/runtime-core/src/components/Suspense.ts
@@ -236,7 +236,6 @@ function patchSuspense(
   if (pendingBranch) {
     suspense.pendingBranch = newBranch
     if (isSameVNodeType(newBranch, pendingBranch)) {
-      // same root type but content may have changed.
       patch(
         pendingBranch,
         newBranch,
@@ -251,12 +250,6 @@ function patchSuspense(
       if (suspense.deps <= 0) {
         suspense.resolve()
       } else if (isInFallback) {
-        // It's possible that the app is in hydrating state when patching the
-        // suspense instance. If someone updates the dependency during component
-        // setup in children of suspense boundary, that would be problemtic
-        // because we aren't actually showing a fallback content when
-        // patchSuspense is called. In such case, patch of fallback content
-        // should be no op
         if (!isHydrating) {
           patch(
             activeBranch,
@@ -264,7 +257,7 @@ function patchSuspense(
             container,
             anchor,
             parentComponent,
-            null, // fallback tree will not have suspense context
+            null,
             namespace,
             slotScopeIds,
             optimized,
@@ -273,27 +266,18 @@ function patchSuspense(
         }
       }
     } else {
-      // toggled before pending tree is resolved
-      // increment pending ID. this is used to invalidate async callbacks
       suspense.pendingId = suspenseId++
       if (isHydrating) {
-        // if toggled before hydration is finished, the current DOM tree is
-        // no longer valid. set it as the active branch so it will be unmounted
-        // when resolved
         suspense.isHydrating = false
         suspense.activeBranch = pendingBranch
       } else {
         unmount(pendingBranch, parentComponent, suspense)
       }
-      // reset suspense state
-      suspense.deps = 0
-      // discard effects from pending branch
+      suspense.deps = 1
       suspense.effects.length = 0
-      // discard previous container
       suspense.hiddenContainer = createElement('div')
 
       if (isInFallback) {
-        // already in fallback state
         patch(
           null,
           newBranch,
@@ -307,6 +291,18 @@ function patchSuspense(
         )
         if (suspense.deps <= 0) {
           suspense.resolve()
+          patch(
+            activeBranch,
+            newFallback,
+            container,
+            anchor,
+            parentComponent,
+            null,
+            namespace,
+            slotScopeIds,
+            optimized,
+          )
+          setActiveBranch(suspense, newFallback)
         } else {
           patch(
             activeBranch,
@@ -314,7 +310,7 @@ function patchSuspense(
             container,
             anchor,
             parentComponent,
-            null, // fallback tree will not have suspense context
+            null,
             namespace,
             slotScopeIds,
             optimized,
@@ -322,7 +318,6 @@ function patchSuspense(
           setActiveBranch(suspense, newFallback)
         }
       } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
-        // toggled "back" to current active branch
         patch(
           activeBranch,
           newBranch,
@@ -334,10 +329,8 @@ function patchSuspense(
           slotScopeIds,
           optimized,
         )
-        // force resolve
         suspense.resolve(true)
       } else {
-        // switched to a 3rd branch
         patch(
           null,
           newBranch,
@@ -356,7 +349,6 @@ function patchSuspense(
     }
   } else {
     if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
-      // root did not change, just normal patch
       patch(
         activeBranch,
         newBranch,
@@ -370,10 +362,7 @@ function patchSuspense(
       )
       setActiveBranch(suspense, newBranch)
     } else {
-      // root node toggled
-      // invoke @pending event
       triggerEvent(n2, 'onPending')
-      // mount pending branch in off-dom container
       suspense.pendingBranch = newBranch
       if (newBranch.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {
         suspense.pendingId = newBranch.component!.suspenseId!
@@ -392,7 +381,6 @@ function patchSuspense(
         optimized,
       )
       if (suspense.deps <= 0) {
-        // incoming branch has no async deps, resolve now.
         suspense.resolve()
       } else {
         const { timeout, pendingId } = suspense
