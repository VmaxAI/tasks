diff --git a/src/plugins/arrayMethods.ts b/src/plugins/arrayMethods.ts
index 9770cf3..8e492ca 100644
--- a/src/plugins/arrayMethods.ts
+++ b/src/plugins/arrayMethods.ts
@@ -198,25 +198,66 @@ export function enableArrayMethods() {
 	 *
 	 * @returns For push/pop/shift/unshift: the native method result. For others: the draft.
 	 */
-	function handleSimpleOperation(
-		state: ProxyArrayState,
-		method: string,
-		args: any[]
-	) {
-		return executeArrayMethod(state, () => {
-			const result = (state.copy_! as any)[method](...args)
-
-			// Handle index reassignment for shifting methods
-			if (SHIFTING_METHODS.has(method as MutatingArrayMethod)) {
-				markAllIndicesReassigned(state)
-			}
-
-			// Return appropriate value based on method
-			return RESULT_RETURNING_METHODS.has(method as MutatingArrayMethod)
-				? result
-				: state.draft_
-		})
-	}
+ def get_most_frequent_word(text: str) -> str:
+     """
+     Returns the most frequently occurring word in the given text.
+     If there is a tie, returns the word that appears first in the text.
+     Words are case-insensitive.
+     Returns an empty string if text is empty or contains no words.
+    
+     Args:
+         text: A string of text
+        
+     Returns:
+         The most frequent word (lowercase), or empty string if no words
+     """
+     if not text:
+         return ""
+    
+     # Convert to lowercase for case-insensitive comparison
+     text_lower = text.lower()
+    
+     # Extract words (only alphanumeric characters)
+     words = []
+     current_word = []
+    
+     for char in text_lower:
+         if char.isalnum():
+             current_word.append(char)
+         else:
+             if current_word:
+                 words.append(''.join(current_word))
+                 current_word = []
+    
+     # Don't forget the last word if text doesn't end with non-alphanumeric
+     if current_word:
+         words.append(''.join(current_word))
+    
+     if not words:
+         return ""
+    
+     # Count frequencies and track first occurrence
+     word_count = {}
+     first_occurrence = {}
+    
+     for index, word in enumerate(words):
+         if word not in word_count:
+             word_count[word] = 0
+             first_occurrence[word] = index
+         word_count[word] += 1
+    
+     # Find the most frequent word (with tie-breaking by first occurrence)
+     most_frequent = ""
+     max_count = 0
+     earliest_index = float('inf')
+    
+     for word, count in word_count.items():
+         if count > max_count or (count == max_count and first_occurrence[word] < earliest_index):
+             most_frequent = word
+             max_count = count
+             earliest_index = first_occurrence[word]
+    
+     return most_frequent
 
 	/**
 	 * Handles reordering operations (reverse, sort) that change element order.
