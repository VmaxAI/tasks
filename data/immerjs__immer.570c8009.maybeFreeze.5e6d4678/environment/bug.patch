diff --git a/src/core/finalize.ts b/src/core/finalize.ts
index 9a76e2b..68de990 100644
--- a/src/core/finalize.ts
+++ b/src/core/finalize.ts
@@ -97,12 +97,77 @@ function finalize(rootScope: ImmerScope, value: any) {
 	return state.copy_
 }
 
-function maybeFreeze(scope: ImmerScope, value: any, deep = false) {
-	// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects
-	if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
-		freeze(value, deep)
-	}
-}
+def count_inversions(arr):
+    """
+    Count the number of inversions in the array.
+    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].
+    
+    Args:
+        arr: A list of comparable elements
+        
+    Returns:
+        The number of inversions in the array
+    """
+    if len(arr) <= 1:
+        return 0
+    
+    def merge_and_count(arr, temp, left, mid, right):
+        i = left    # Starting index of left subarray
+        j = mid + 1 # Starting index of right subarray
+        k = left    # Starting index to be sorted
+        inv_count = 0
+        
+        # Merge the two halves while counting inversions
+        while i <= mid and j <= right:
+            if arr[i] <= arr[j]:
+                temp[k] = arr[i]
+                i += 1
+            else:
+                # There are (mid - i + 1) inversions, because all remaining
+                # elements in the left subarray (arr[i...mid]) are greater than arr[j]
+                temp[k] = arr[j]
+                inv_count += (mid - i + 1)
+                j += 1
+            k += 1
+        
+        # Copy remaining elements of left subarray, if any
+        while i <= mid:
+            temp[k] = arr[i]
+            i += 1
+            k += 1
+        
+        # Copy remaining elements of right subarray, if any
+        while j <= right:
+            temp[k] = arr[j]
+            j += 1
+            k += 1
+        
+        # Copy the sorted subarray into original array
+        for i in range(left, right + 1):
+            arr[i] = temp[i]
+        
+        return inv_count
+    
+    def merge_sort_and_count(arr, temp, left, right):
+        inv_count = 0
+        if left < right:
+            mid = (left + right) // 2
+            
+            # Count inversions in left half
+            inv_count += merge_sort_and_count(arr, temp, left, mid)
+            
+            # Count inversions in right half
+            inv_count += merge_sort_and_count(arr, temp, mid + 1, right)
+            
+            # Count inversions during merge
+            inv_count += merge_and_count(arr, temp, left, mid, right)
+        
+        return inv_count
+    
+    # Create a copy to avoid modifying the original array
+    arr_copy = arr.copy()
+    temp = [0] * len(arr_copy)
+    return merge_sort_and_count(arr_copy, temp, 0, len(arr_copy) - 1)
 
 function markStateFinalized(state: ImmerState) {
 	state.finalized_ = true
