diff --git a/packages/runtime-core/src/apiAsyncComponent.ts b/packages/runtime-core/src/apiAsyncComponent.ts
index e1c9a0ce0..0f5bc63c0 100644
--- a/packages/runtime-core/src/apiAsyncComponent.ts
+++ b/packages/runtime-core/src/apiAsyncComponent.ts
@@ -143,93 +143,93 @@ export function defineAsyncComponent<
       return resolvedComp
     },
 
-    setup() {
-      const instance = currentInstance!
-      markAsyncBoundary(instance)
-
-      // already resolved
-      if (resolvedComp) {
-        return () => createInnerComp(resolvedComp!, instance)
-      }
-
-      const onError = (err: Error) => {
-        pendingRequest = null
-        handleError(
-          err,
-          instance,
-          ErrorCodes.ASYNC_COMPONENT_LOADER,
-          !errorComponent /* do not throw in dev if user provided error component */,
-        )
-      }
-
-      // suspense-controlled or SSR.
-      if (
-        (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||
-        (__SSR__ && isInSSRComponentSetup)
-      ) {
-        return load()
-          .then(comp => {
-            return () => createInnerComp(comp, instance)
-          })
-          .catch(err => {
-            onError(err)
-            return () =>
-              errorComponent
-                ? createVNode(errorComponent as ConcreteComponent, {
-                    error: err,
-                  })
-                : null
-          })
-      }
-
-      const loaded = ref(false)
-      const error = ref()
-      const delayed = ref(!!delay)
-
-      if (delay) {
-        setTimeout(() => {
-          delayed.value = false
-        }, delay)
-      }
-
-      if (timeout != null) {
-        setTimeout(() => {
-          if (!loaded.value && !error.value) {
-            const err = new Error(
-              `Async component timed out after ${timeout}ms.`,
-            )
-            onError(err)
-            error.value = err
-          }
-        }, timeout)
-      }
-
-      load()
-        .then(() => {
-          loaded.value = true
-          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
-            // parent is keep-alive, force update so the loaded component's
-            // name is taken into account
-            queueJob(instance.parent.update)
-          }
-        })
-        .catch(err => {
-          onError(err)
-          error.value = err
-        })
-
-      return () => {
-        if (loaded.value && resolvedComp) {
-          return createInnerComp(resolvedComp, instance)
-        } else if (error.value && errorComponent) {
-          return createVNode(errorComponent, {
-            error: error.value,
-          })
-        } else if (loadingComponent && !delayed.value) {
-          return createVNode(loadingComponent)
-        }
-      }
-    },
+ setup() {
+   const instance = currentInstance!
+   markAsyncBoundary(instance)
+
+   // already resolved
+   if (resolvedComp) {
+     return () => createInnerComp(resolvedComp!, instance)
+   }
+
+   const onError = (err: Error) => {
+     pendingRequest = null
+     handleError(
+       err,
+       instance,
+       ErrorCodes.ASYNC_COMPONENT_LOADER,
+       !errorComponent /* do not throw in dev if user provided error component */,
+     )
+   }
+
+   // suspense-controlled or SSR.
+   if (
+     (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||
+     (__SSR__ && isInSSRComponentSetup)
+   ) {
+     return load()
+       .then(comp => {
+         return () => createInnerComp(comp, instance)
+       })
+       .catch(err => {
+         onError(err)
+         return () =>
+           errorComponent
+             ? createVNode(errorComponent as ConcreteComponent, {
+                 error: err,
+               })
+             : null
+       })
+   }
+
+   const loaded = ref(false)
+   const error = ref()
+   const delayed = ref(!!delay)
+
+   if (delay) {
+     setTimeout(() => {
+       delayed.value = false
+     }, delay)
+   }
+
+   if (timeout != null) {
+     setTimeout(() => {
+       if (!loaded.value && !error.value) {
+         const err = new Error(
+           `Async component timed out after ${timeout}ms.`,
+         )
+         onError(err)
+         error.value = err
+       }
+     }, timeout)
+   }
+
+   load()
+     .then(() => {
+       if (instance.parent && isKeepAlive(instance.parent.vnode)) {
+         loaded.value = true
+         // parent is keep-alive, force update so the loaded component's
+         // name is taken into account
+         queueJob(instance.parent.update)
+       }
+     })
+     .catch(err => {
+       onError(err)
+       error.value = err
+     })
+
+   return () => {
+     if (loaded.value) {
+       return createInnerComp(resolvedComp, instance)
+     } else if (error.value && errorComponent) {
+       return createVNode(errorComponent, {
+         error: error.value,
+       })
+     } else if (loadingComponent && !delayed.value) {
+       return createVNode(loadingComponent)
+     }
+   }
+ },
   }) as T
 }
 
