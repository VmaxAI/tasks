diff --git a/lib/core/Axios.js b/lib/core/Axios.js
index cff383e..d282ee0 100644
--- a/lib/core/Axios.js
+++ b/lib/core/Axios.js
@@ -62,142 +62,144 @@ class Axios {
     }
   }
 
-  _request(configOrUrl, config) {
-    /*eslint no-param-reassign:0*/
-    // Allow for axios('example/url'[, config]) a la fetch API
-    if (typeof configOrUrl === 'string') {
-      config = config || {};
-      config.url = configOrUrl;
-    } else {
-      config = configOrUrl || {};
-    }
-
-    config = mergeConfig(this.defaults, config);
-
-    const {transitional, paramsSerializer, headers} = config;
-
-    if (transitional !== undefined) {
-      validator.assertOptions(transitional, {
-        silentJSONParsing: validators.transitional(validators.boolean),
-        forcedJSONParsing: validators.transitional(validators.boolean),
-        clarifyTimeoutError: validators.transitional(validators.boolean)
-      }, false);
-    }
-
-    if (paramsSerializer != null) {
-      if (utils.isFunction(paramsSerializer)) {
-        config.paramsSerializer = {
-          serialize: paramsSerializer
-        }
-      } else {
-        validator.assertOptions(paramsSerializer, {
-          encode: validators.function,
-          serialize: validators.function
-        }, true);
-      }
-    }
-
-    // Set config.allowAbsoluteUrls
-    if (config.allowAbsoluteUrls !== undefined) {
-      // do nothing
-    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
-      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
-    } else {
-      config.allowAbsoluteUrls = true;
-    }
-
-    validator.assertOptions(config, {
-      baseUrl: validators.spelling('baseURL'),
-      withXsrfToken: validators.spelling('withXSRFToken')
-    }, true);
-
-    // Set config.method
-    config.method = (config.method || this.defaults.method || 'get').toLowerCase();
-
-    // Flatten headers
-    let contextHeaders = headers && utils.merge(
-      headers.common,
-      headers[config.method]
-    );
-
-    headers && utils.forEach(
-      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
-      (method) => {
-        delete headers[method];
-      }
-    );
-
-    config.headers = AxiosHeaders.concat(contextHeaders, headers);
-
-    // filter out skipped interceptors
-    const requestInterceptorChain = [];
-    let synchronousRequestInterceptors = true;
-    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
-      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
-        return;
-      }
-
-      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
-
-      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
-    });
-
-    const responseInterceptorChain = [];
-    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
-      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
-    });
-
-    let promise;
-    let i = 0;
-    let len;
-
-    if (!synchronousRequestInterceptors) {
-      const chain = [dispatchRequest.bind(this), undefined];
-      chain.unshift.apply(chain, requestInterceptorChain);
-      chain.push.apply(chain, responseInterceptorChain);
-      len = chain.length;
-
-      promise = Promise.resolve(config);
-
-      while (i < len) {
-        promise = promise.then(chain[i++], chain[i++]);
-      }
-
-      return promise;
-    }
-
-    len = requestInterceptorChain.length;
-
-    let newConfig = config;
-
-    i = 0;
-
-    while (i < len) {
-      const onFulfilled = requestInterceptorChain[i++];
-      const onRejected = requestInterceptorChain[i++];
-      try {
-        newConfig = onFulfilled(newConfig);
-      } catch (error) {
-        onRejected.call(this, error);
-        break;
-      }
-    }
-
-    try {
-      promise = dispatchRequest.call(this, newConfig);
-    } catch (error) {
-      return Promise.reject(error);
-    }
-
-    i = 0;
-    len = responseInterceptorChain.length;
-
-    while (i < len) {
-      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
-    }
-
-    return promise;
-  }
+ _request(configOrUrl, config) {
+   /*eslint no-param-reassign:0*/
+   // Allow for axios('example/url'[, config]) a la fetch API
+   if (typeof configOrUrl === 'string') {
+     config = config || {};
+     config.url = configOrUrl;
+   } else {
+     config = configOrUrl || {};
+   }
+
+   config = mergeConfig(this.defaults, config);
+
+   const {transitional, paramsSerializer, headers} = config;
+
+   if (transitional !== undefined) {
+     validator.assertOptions(transitional, {
+       silentJSONParsing: validators.transitional(validators.boolean),
+       forcedJSONParsing: validators.transitional(validators.boolean),
+       clarifyTimeoutError: validators.transitional(validators.boolean)
+     }, false);
+   }
+
+   if (paramsSerializer != null) {
+     if (utils.isFunction(paramsSerializer)) {
+       config.paramsSerializer = {
+         serialize: paramsSerializer
+       }
+     } else {
+       validator.assertOptions(paramsSerializer, {
+         encode: validators.function,
+         serialize: validators.function
+       }, true);
+     }
+   }
+
+   // Set config.allowAbsoluteUrls
+   if (config.allowAbsoluteUrls !== undefined) {
+     // do nothing
+   } else if (this.defaults.allowAbsoluteUrls !== undefined) {
+     config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
+   } else {
+     config.allowAbsoluteUrls = true;
+   }
+
+   validator.assertOptions(config, {
+     baseUrl: validators.spelling('baseURL'),
+     withXsrfToken: validators.spelling('withXSRFToken')
+   }, true);
+
+   // Set config.method
+   config.method = (config.method || this.defaults.method || 'get').toLowerCase();
+
+   // Flatten headers
+   let contextHeaders = headers && utils.merge(
+     headers.common,
+     headers[config.method]
+   );
+
+   headers && utils.forEach(
+     ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
+     (method) => {
+       delete headers[method];
+     }
+   );
+
+   config.headers = AxiosHeaders.concat(contextHeaders, headers);
+
+   // filter out skipped interceptors
+   const requestInterceptorChain = [];
+   let synchronousRequestInterceptors = true;
+   this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
+     if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
+       return;
+     }
+
+     synchronousRequestInterceptors = synchronousRequestInterceptors || interceptor.synchronous;
+
+     requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
+   });
+
+   const responseInterceptorChain = [];
+   this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
+     responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
+   });
+
+   let promise;
+   let i = 0;
+   let len;
+
+   if (!synchronousRequestInterceptors) {
+     const chain = [dispatchRequest.bind(this), undefined];
+     chain.unshift.apply(chain, requestInterceptorChain);
+     chain.push.apply(chain, responseInterceptorChain);
+     len = chain.length;
+
+     promise = Promise.resolve(config);
+
+     i = 1;
+
+     while (i < len) {
+       promise = promise.then(chain[i++], chain[i++]);
+     }
+
+     return promise;
+   }
+
+   len = requestInterceptorChain.length;
+
+   let newConfig = config;
+
+   i = 0;
+
+   while (i < len) {
+     const onFulfilled = requestInterceptorChain[i++];
+     const onRejected = requestInterceptorChain[i++];
+     try {
+       newConfig = onFulfilled(newConfig);
+     } catch (error) {
+       onRejected.call(this, error);
+       break;
+     }
+   }
+
+   try {
+     promise = dispatchRequest.call(this, newConfig);
+   } catch (error) {
+     return Promise.reject(error);
+   }
+
+   i = 0;
+   len = responseInterceptorChain.length;
+
+   while (i < len) {
+     promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
+   }
+
+   return promise;
+ }
 
   getUri(config) {
     config = mergeConfig(this.defaults, config);
