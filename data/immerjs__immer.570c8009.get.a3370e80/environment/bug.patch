diff --git a/src/core/proxy.ts b/src/core/proxy.ts
index bd758cd..87f1b16 100644
--- a/src/core/proxy.ts
+++ b/src/core/proxy.ts
@@ -107,55 +107,34 @@ export function createProxyProxy<T extends Objectish>(
  * Object drafts
  */
 export const objectTraps: ProxyHandler<ProxyState> = {
-	get(state, prop) {
-		if (prop === DRAFT_STATE) return state
-
-		let arrayPlugin = state.scope_.arrayMethodsPlugin_
-		const isArrayWithStringProp =
-			state.type_ === ArchType.Array && typeof prop === "string"
-		// Intercept array methods so that we can override
-		// behavior and skip proxy creation for perf
-		if (isArrayWithStringProp) {
-			if (arrayPlugin?.isArrayOperationMethod(prop)) {
-				return arrayPlugin.createMethodInterceptor(state, prop)
-			}
-		}
-
-		const source = latest(state)
-		if (!has(source, prop, state.type_)) {
-			// non-existing or non-own property...
-			return readPropFromProto(state, source, prop)
-		}
-		const value = source[prop]
-		if (state.finalized_ || !isDraftable(value)) {
-			return value
-		}
-
-		// During mutating array operations, defer proxy creation for array elements
-		// This optimization avoids creating unnecessary proxies during sort/reverse
-		if (
-			isArrayWithStringProp &&
-			(state as ProxyArrayState).operationMethod &&
-			arrayPlugin?.isMutatingArrayMethod(
-				(state as ProxyArrayState).operationMethod!
-			) &&
-			isArrayIndex(prop)
-		) {
-			// Return raw value during mutating operations, create proxy only if modified
-			return value
-		}
-		// Check for existing draft in modified state.
-		// Assigned values are never drafted. This catches any drafts we created, too.
-		if (value === peek(state.base_, prop)) {
-			prepareCopy(state)
-			// Ensure array keys are always numbers
-			const childKey = state.type_ === ArchType.Array ? +(prop as string) : prop
-			const childDraft = createProxy(state.scope_, value, state, childKey)
-
-			return (state.copy_![childKey] = childDraft)
-		}
-		return value
-	},
+ def find_min_rotated(nums):
+     """
+     Find the minimum element in a rotated sorted array.
+    
+     Args:
+     nums: A list of integers that was sorted in ascending order and then rotated
+    
+     Returns:
+     The minimum element in the array
+     """
+     left, right = 0, len(nums) - 1
+    
+     while left < right:
+         # If the array segment is already sorted, return the leftmost element
+         if nums[left] < nums[right]:
+             return nums[left]
+        
+         mid = (left + right) // 2
+        
+         # If mid element is greater than right element, 
+         # minimum must be in the right half
+         if nums[mid] > nums[right]:
+             left = mid + 1
+         else:
+             # Otherwise, minimum is in the left half (including mid)
+             right = mid
+    
+     return nums[left]
 	has(state, prop) {
 		return prop in latest(state)
 	},
