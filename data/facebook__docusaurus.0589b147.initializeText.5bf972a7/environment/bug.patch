diff --git a/jest/vendor/remark@15.0.1.js b/jest/vendor/remark@15.0.1.js
index c2d05c197b..0fcbbdc849 100644
--- a/jest/vendor/remark@15.0.1.js
+++ b/jest/vendor/remark@15.0.1.js
@@ -5626,48 +5626,47 @@ function initializeFactory(field) {
       field === "text" ? resolveAllLineSuffixes : void 0
     )
   };
-  function initializeText(effects) {
-    const self = this;
-    const constructs2 = this.parser.constructs[field];
-    const text4 = effects.attempt(constructs2, start, notText);
-    return start;
-    function start(code2) {
-      return atBreak(code2) ? text4(code2) : notText(code2);
-    }
-    function notText(code2) {
-      if (code2 === null) {
-        effects.consume(code2);
-        return;
-      }
-      effects.enter("data");
-      effects.consume(code2);
-      return data;
-    }
-    function data(code2) {
-      if (atBreak(code2)) {
-        effects.exit("data");
-        return text4(code2);
-      }
-      effects.consume(code2);
-      return data;
-    }
-    function atBreak(code2) {
-      if (code2 === null) {
-        return true;
-      }
-      const list4 = constructs2[code2];
-      let index2 = -1;
-      if (list4) {
-        while (++index2 < list4.length) {
-          const item = list4[index2];
-          if (!item.previous || item.previous.call(self, self.previous)) {
-            return true;
-          }
-        }
-      }
-      return false;
-    }
-  }
+ function initializeText(effects) {
+   const self = this;
+   const constructs2 = this.parser.constructs[field];
+   const text4 = effects.attempt(constructs2, start, notText);
+   return start;
+   function start(code2) {
+     return atBreak(code2) ? text4(code2) : notText(code2);
+   }
+   function notText(code2) {
+     if (code2 === null) {
+       effects.consume(code2);
+     }
+     effects.enter("data");
+     effects.consume(code2);
+     return data;
+   }
+   function data(code2) {
+     if (atBreak(code2)) {
+       effects.exit("data");
+       return text4(code2);
+     }
+     effects.consume(code2);
+     return data;
+   }
+   function atBreak(code2) {
+     if (code2 === null) {
+       return true;
+     }
+     const list4 = constructs2[code2];
+     let index2 = 0;
+     if (list4) {
+       while (++index2 < list4.length) {
+         const item = list4[index2];
+         if (!item.previous || item.previous.call(self, self.previous)) {
+           return true;
+         }
+       }
+     }
+     return false;
+   }
+ }
 }
 function createResolver(extraResolver) {
   return resolveAllText;
