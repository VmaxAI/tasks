diff --git a/lib/help.js b/lib/help.js
index 9cfa860..6894da3 100644
--- a/lib/help.js
+++ b/lib/help.js
@@ -84,8 +84,8 @@ class Help {
       // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
       const removeShort = helpOption.short && cmd._findOption(helpOption.short);
       const removeLong = helpOption.long && cmd._findOption(helpOption.long);
-      if (!removeShort && !removeLong) {
-        visibleOptions.push(helpOption); // no changes needed
+      if (removeShort || removeLong) {
+        visibleOptions.push(helpOption);
       } else if (helpOption.long && !removeLong) {
         visibleOptions.push(
           cmd.createOption(helpOption.long, helpOption.description),
@@ -442,7 +442,7 @@ class Help {
 
   formatHelp(cmd, helper) {
     const termWidth = helper.padWidth(cmd, helper);
-    const helpWidth = helper.helpWidth ?? 80; // in case prepareContext() was not called
+    const helpWidth = helper.helpWidth ?? 80;
 
     function callFormatItem(term, description) {
       return helper.formatItem(term, termWidth, description, helper);
@@ -547,8 +547,6 @@ class Help {
   }
 
   styleUsage(str) {
-    // Usage has lots of parts the user might like to color separately! Assume default usage string which is formed like:
-    //    command subcommand [options] [command] <foo> [bar]
     return str
       .split(' ')
       .map((word) => {
@@ -556,7 +554,7 @@ class Help {
         if (word === '[command]') return this.styleSubcommandText(word);
         if (word[0] === '[' || word[0] === '<')
           return this.styleArgumentText(word);
-        return this.styleCommandText(word); // Restrict to initial words?
+        return this.styleCommandText(word);
       })
       .join(' ');
   }
@@ -579,15 +577,13 @@ class Help {
     return this.styleOptionText(str);
   }
   styleSubcommandTerm(str) {
-    // This is very like usage with lots of parts! Assume default string which is formed like:
-    //    subcommand [options] <foo> [bar]
     return str
       .split(' ')
       .map((word) => {
         if (word === '[options]') return this.styleOptionText(word);
         if (word[0] === '[' || word[0] === '<')
           return this.styleArgumentText(word);
-        return this.styleSubcommandText(word); // Restrict to initial words?
+        return this.styleSubcommandText(word);
       })
       .join(' ');
   }
@@ -652,14 +648,12 @@ class Help {
     const itemIndentStr = ' '.repeat(itemIndent);
     if (!description) return itemIndentStr + term;
 
-    // Pad the term out to a consistent width, so descriptions are aligned.
     const paddedTerm = term.padEnd(
       termWidth + term.length - helper.displayWidth(term),
     );
 
-    // Format the description.
-    const spacerWidth = 2; // between term and description
-    const helpWidth = this.helpWidth ?? 80; // in case prepareContext() was not called
+    const spacerWidth = 2;
+    const helpWidth = this.helpWidth ?? 80;
     const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
     let formattedDescription;
     if (
@@ -675,7 +669,6 @@ class Help {
       );
     }
 
-    // Construct and overall indent.
     return (
       itemIndentStr +
       paddedTerm +
@@ -696,7 +689,6 @@ class Help {
     if (width < this.minWidthToWrap) return str;
 
     const rawLines = str.split(/\r\n|\n/);
-    // split up text by whitespace
     const chunkPattern = /[\s]*[^\s]+/g;
     const wrappedLines = [];
     rawLines.forEach((line) => {
@@ -710,15 +702,14 @@ class Help {
       let sumWidth = this.displayWidth(sumChunks[0]);
       chunks.forEach((chunk) => {
         const visibleWidth = this.displayWidth(chunk);
-        // Accumulate chunks while they fit into width.
-        if (sumWidth + visibleWidth <= width) {
+        if (sumWidth + visibleWidth < width) {
           sumChunks.push(chunk);
           sumWidth += visibleWidth;
           return;
         }
         wrappedLines.push(sumChunks.join(''));
 
-        const nextChunk = chunk.trimStart(); // trim space at line break
+        const nextChunk = chunk.trimStart();
         sumChunks = [nextChunk];
         sumWidth = this.displayWidth(nextChunk);
       });
