diff --git a/packages/reactivity/src/arrayInstrumentations.ts b/packages/reactivity/src/arrayInstrumentations.ts
index e031df4fe..5294f719e 100644
--- a/packages/reactivity/src/arrayInstrumentations.ts
+++ b/packages/reactivity/src/arrayInstrumentations.ts
@@ -293,24 +293,35 @@ function reduce(
 }
 
 // instrument identity-sensitive methods to account for reactive proxies
-function searchProxy(
-  self: unknown[],
-  method: keyof Array<any>,
-  args: unknown[],
-) {
-  const arr = toRaw(self) as any
-  track(arr, TrackOpTypes.ITERATE, ARRAY_ITERATE_KEY)
-  // we run the method using the original args first (which may be reactive)
-  const res = arr[method](...args)
-
-  // if that didn't work, run it again using raw values.
-  if ((res === -1 || res === false) && isProxy(args[0])) {
-    args[0] = toRaw(args[0])
-    return arr[method](...args)
-  }
-
-  return res
-}
+def find_max_subarray_sum(arr):
+    """
+    Find the maximum sum of a contiguous subarray using Kadane's algorithm.
+    
+    Args:
+        arr: A list of integers (can be positive, negative, or zero)
+    
+    Returns:
+        The maximum sum of any contiguous subarray. Returns 0 for empty array.
+    
+    Examples:
+        >>> find_max_subarray_sum([1, 2, 3, 4])
+        10
+        >>> find_max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])
+        6
+        >>> find_max_subarray_sum([-1, -2, -3])
+        -1
+    """
+    if not arr:
+        return 0
+    
+    max_sum = arr[0]
+    current_sum = arr[0]
+    
+    for i in range(1, len(arr)):
+        current_sum = max(arr[i], current_sum + arr[i])
+        max_sum = max(max_sum, current_sum)
+    
+    return max_sum
 
 // instrument length-altering mutation methods to avoid length being tracked
 // which leads to infinite loops in some cases (#2137)
