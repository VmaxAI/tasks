diff --git a/lib/help.js b/lib/help.js
index 9cfa860..1c4ee6f 100644
--- a/lib/help.js
+++ b/lib/help.js
@@ -76,31 +76,66 @@ class Help {
    * @returns {Option[]}
    */
 
-  visibleOptions(cmd) {
-    const visibleOptions = cmd.options.filter((option) => !option.hidden);
-    // Built-in help option.
-    const helpOption = cmd._getHelpOption();
-    if (helpOption && !helpOption.hidden) {
-      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
-      const removeShort = helpOption.short && cmd._findOption(helpOption.short);
-      const removeLong = helpOption.long && cmd._findOption(helpOption.long);
-      if (!removeShort && !removeLong) {
-        visibleOptions.push(helpOption); // no changes needed
-      } else if (helpOption.long && !removeLong) {
-        visibleOptions.push(
-          cmd.createOption(helpOption.long, helpOption.description),
-        );
-      } else if (helpOption.short && !removeShort) {
-        visibleOptions.push(
-          cmd.createOption(helpOption.short, helpOption.description),
-        );
-      }
-    }
-    if (this.sortOptions) {
-      visibleOptions.sort(this.compareOptions);
-    }
-    return visibleOptions;
-  }
+ def parse_expression(expression):
+     """
+     Parses and evaluates a mathematical expression.
+    
+     Args:
+         expression: A string containing a mathematical expression with
+                    numbers, operators (+, -, *, /), and parentheses.
+    
+     Returns:
+         The result of evaluating the expression.
+     """
+     expression = expression.replace(' ', '')  # Remove whitespace
+     pos = [0]  # Use list to allow modification in nested functions
+    
+     def parse_number():
+         start = pos[0]
+         if pos[0] < len(expression) and expression[pos[0]] == '-':
+             pos[0] += 1
+         while pos[0] < len(expression) and (expression[pos[0]].isdigit() or expression[pos[0]] == '.'):
+             pos[0] += 1
+         return float(expression[start:pos[0]])
+    
+     def parse_factor():
+         if expression[pos[0]] == '(':
+             pos[0] += 1  # Skip '('
+             result = parse_expr()
+             pos[0] += 1  # Skip ')'
+             return result
+         else:
+             return parse_number()
+    
+     def parse_term():
+         result = parse_factor()
+         while pos[0] < len(expression) and expression[pos[0]] in '*/':
+             op = expression[pos[0]]
+             pos[0] += 1
+             right = parse_factor()
+             if op == '*':
+                 result *= right
+             else:
+                 result /= right
+         return result
+    
+     def parse_expr():
+         result = parse_term()
+         while pos[0] < len(expression) and expression[pos[0]] in '+-':
+             op = expression[pos[0]]
+             pos[0] += 1
+             right = parse_term()
+             if op == '+':
+                 result += right
+             else:
+                 result -= right
+         return result
+    
+     result = parse_expr()
+     # Return as int if it's a whole number, otherwise as float
+     if result == int(result):
+         return int(result)
+     return result
 
   /**
    * Get an array of the visible global options. (Not including help.)
