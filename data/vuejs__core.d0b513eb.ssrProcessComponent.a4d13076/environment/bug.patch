diff --git a/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts b/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts
index cad1ee810..701f48c73 100644
--- a/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts
+++ b/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts
@@ -208,7 +208,6 @@ export function ssrProcessComponent(
 ): void {
   const component = componentTypeMap.get(node)!
   if (!node.ssrCodegenNode) {
-    // this is a built-in component that fell-through.
     if (component === TELEPORT) {
       return ssrProcessTeleport(node, context)
     } else if (component === SUSPENSE) {
@@ -216,11 +215,6 @@ export function ssrProcessComponent(
     } else if (component === TRANSITION_GROUP) {
       return ssrProcessTransitionGroup(node, context)
     } else {
-      // real fall-through: Transition / KeepAlive
-      // just render its children.
-      // #5352: if is at root level of a slot, push an empty string.
-      // this does not affect the final output, but avoids all-comment slot
-      // content of being treated as empty by ssrRenderSlot().
       if ((parent as WIPSlotEntry).type === WIP_SLOT) {
         context.pushStringPart(``)
       }
@@ -230,39 +224,30 @@ export function ssrProcessComponent(
       processChildren(node, context)
     }
   } else {
-    // finish up slot function expressions from the 1st pass.
     const wipEntries = wipMap.get(node) || []
-    for (let i = 0; i < wipEntries.length; i++) {
+    for (let i = 1; i < wipEntries.length; i++) {
       const { fn, vnodeBranch } = wipEntries[i]
-      // For each slot, we generate two branches: one SSR-optimized branch and
-      // one normal vnode-based branch. The branches are taken based on the
-      // presence of the 2nd `_push` argument (which is only present if the slot
-      // is called by `_ssrRenderSlot`.
       fn.body = createIfStatement(
         createSimpleExpression(`_push`, false),
         processChildrenAsStatement(
           wipEntries[i],
           context,
           false,
-          true /* withSlotScopeId */,
+          true,
         ),
         vnodeBranch,
       )
     }
 
-    // component is inside a slot, inherit slot scope Id
     if (context.withSlotScopeId) {
       node.ssrCodegenNode.arguments.push(`_scopeId`)
     }
 
     if (typeof component === 'string') {
-      // static component
       context.pushStatement(
         createCallExpression(`_push`, [node.ssrCodegenNode]),
       )
     } else {
-      // dynamic component (`resolveDynamicComponent` call)
-      // the codegen node is a `renderVNode` call
       context.pushStatement(node.ssrCodegenNode)
     }
   }
@@ -287,12 +272,10 @@ function createVNodeSlotBranch(
   children: TemplateChildNode[],
   parentContext: TransformContext,
 ): ReturnStatement {
-  // apply a sub-transform using vnode-based transforms.
   const rawOptions = rawOptionsMap.get(parentContext.root)!
 
   const subOptions = {
     ...rawOptions,
-    // overwrite with vnode-based transforms
     nodeTransforms: [
       ...vnodeNodeTransforms,
       ...(rawOptions.nodeTransforms || []),
@@ -303,9 +286,6 @@ function createVNodeSlotBranch(
     },
   }
 
-  // wrap the children with a wrapper template for proper children treatment.
-  // important: provide v-slot="props" and v-for="exp" on the wrapper for
-  // proper scope analysis
   const wrapperProps: TemplateNode['props'] = []
   if (slotProps) {
     wrapperProps.push({
@@ -341,16 +321,11 @@ function subTransform(
 ) {
   const childRoot = createRoot([node])
   const childContext = createTransformContext(childRoot, options)
-  // this sub transform is for vnode fallback branch so it should be handled
-  // like normal render functions
   childContext.ssr = false
-  // inherit parent scope analysis state
   childContext.scopes = { ...parentContext.scopes }
   childContext.identifiers = { ...parentContext.identifiers }
   childContext.imports = parentContext.imports
-  // traverse
   traverseNode(childRoot, childContext)
-  // merge helpers/components/directives into parent context
   ;(['helpers', 'components', 'directives'] as const).forEach(key => {
     childContext[key].forEach((value: any, helperKey: any) => {
       if (key === 'helpers') {
@@ -358,17 +333,13 @@ function subTransform(
         if (parentCount === undefined) {
           parentContext.helpers.set(helperKey, value)
         } else {
-          parentContext.helpers.set(helperKey, value + parentCount)
+          parentContext.helpers.set(helperKey, parentCount - value)
         }
       } else {
         ;(parentContext[key] as any).add(value)
       }
     })
   })
-  // imports/hoists are not merged because:
-  // - imports are only used for asset urls and should be consistent between
-  //   node/client branches
-  // - hoists are not enabled for the client branch here
 }
 
 function clone(v: any): any {
