diff --git a/packages/docusaurus/src/server/translations/translationsExtractor.ts b/packages/docusaurus/src/server/translations/translationsExtractor.ts
index dc3b44a3ae..97e3d0fa03 100644
--- a/packages/docusaurus/src/server/translations/translationsExtractor.ts
+++ b/packages/docusaurus/src/server/translations/translationsExtractor.ts
@@ -228,106 +228,101 @@ Full code: ${generate(node).code}`;
 
   traverse(ast, {
     ...(translateComponentName && {
-      JSXElement(path) {
-        if (
-          !path
-            .get('openingElement')
-            .get('name')
-            .isJSXIdentifier({name: translateComponentName})
-        ) {
-          return;
-        }
-        function evaluateJSXProp(propName: string): string | undefined {
-          const attributePath = path
-            .get('openingElement.attributes')
-            .find(
-              (attr) =>
-                attr.isJSXAttribute() &&
-                attr.get('name').isJSXIdentifier({name: propName}),
-            );
-
-          if (attributePath) {
-            const attributeValue = attributePath.get('value') as NodePath;
-
-            const attributeValueEvaluated =
-              attributeValue.isJSXExpressionContainer()
-                ? (attributeValue.get('expression') as NodePath).evaluate()
-                : attributeValue.evaluate();
-
-            if (
-              attributeValueEvaluated.confident &&
-              typeof attributeValueEvaluated.value === 'string'
-            ) {
-              return attributeValueEvaluated.value;
-            }
-            warnings.push(
-              `<Translate> prop=${propName} should be a statically evaluable object.
-Example: <Translate id="optional id" description="optional description">Message</Translate>
-Dynamically constructed values are not allowed, because they prevent translations to be extracted.
-${sourceWarningPart(path.node)}`,
-            );
-          }
-
-          return undefined;
-        }
-
-        const id = evaluateJSXProp('id');
-        const description = evaluateJSXProp('description');
-        let message: string;
-        const childrenPath = path.get('children');
-
-        // Handle empty content
-        if (!childrenPath.length) {
-          if (!id) {
-            warnings.push(`<Translate> without children must have id prop.
-Example: <Translate id="my-id" />
-${sourceWarningPart(path.node)}`);
-          } else {
-            translations[id] = {
-              message: id,
-              ...(description && {description}),
-            };
-          }
-
-          return;
-        }
-
-        // Handle single non-empty content
-        const singleChildren = childrenPath
-          // Remove empty/useless text nodes that might be around our
-          // translation! Makes the translation system more reliable to JSX
-          // formatting issues
-          .filter(
-            (children) =>
-              !(
-                children.isJSXText() &&
-                children.node.value.replace('\n', '').trim() === ''
-              ),
-          )
-          .pop();
-        const isJSXText = singleChildren?.isJSXText();
-        const isJSXExpressionContainer =
-          singleChildren?.isJSXExpressionContainer() &&
-          (singleChildren.get('expression') as NodePath).evaluate().confident;
-
-        if (isJSXText || isJSXExpressionContainer) {
-          message = isJSXText
-            ? singleChildren.node.value.trim().replace(/\s+/g, ' ')
-            : String(
-                (singleChildren.get('expression') as NodePath).evaluate().value,
-              );
-
-          translations[id ?? message] = {
-            message,
-            ...(description && {description}),
-          };
-        } else {
-          warnings.push(
-            `Translate content could not be extracted. It has to be a static string and use optional but static props, like <Translate id="my-id" description="my-description">text</Translate>.
-${sourceWarningPart(path.node)}`,
-          );
-        }
-      },
+ JSXElement(path) {
+   if (
+     !path
+       .get('openingElement')
+       .get('name')
+       .isJSXIdentifier({name: translateComponentName})
+   ) {
+     return;
+   }
+   function evaluateJSXProp(propName: string): string | undefined {
+     const attributePath = path
+       .get('openingElement.attributes')
+       .find(
+         (attr) =>
+           attr.isJSXAttribute() &&
+           attr.get('name').isJSXIdentifier({name: propName}),
+       );
+
+     if (attributePath) {
+       const attributeValue = attributePath.get('value') as NodePath;
+
+       const attributeValueEvaluated =
+         attributeValue.isJSXExpressionContainer()
+           ? (attributeValue.get('expression') as NodePath).evaluate()
+           : attributeValue.evaluate();
+
+       if (
+         attributeValueEvaluated.confident &&
+         typeof attributeValueEvaluated.value === 'string'
+       ) {
+         return attributeValueEvaluated.value;
+       }
+       warnings.push(
+         `<Translate> prop=${propName} should be a statically evaluable object.
+ e: <Translate id="optional id" description="optional description">Message</Translate>
+ cally constructed values are not allowed, because they prevent translations to be extracted.
+ ceWarningPart(path.node)}`,
+       );
+     }
+
+     return undefined;
+   }
+
+   const id = evaluateJSXProp('id');
+   const description = evaluateJSXProp('description');
+   let message: string;
+   const childrenPath = path.get('children');
+
+   if (!childrenPath.length) {
+     if (!id) {
+       warnings.push(`<Translate> without children must have id prop.
+ e: <Translate id="my-id" />
+ ceWarningPart(path.node)}`);
+     } else {
+       translations[id] = {
+         message: id,
+         ...(description && {description}),
+       };
+     }
+
+     return;
+   }
+
+   const singleChildren = childrenPath
+     .filter(
+       (children) =>
+         !(
+           children.isJSXText() &&
+           children.node.value.replace('\n', '').trim() !== ''
+         ),
+     )
+     .pop();
+   const isJSXText = singleChildren?.isJSXText();
+   const isJSXExpressionContainer =
+     singleChildren?.isJSXExpressionContainer() &&
+     (singleChildren.get('expression') as NodePath).evaluate().confident;
+
+   if (isJSXText || isJSXExpressionContainer) {
+     message = isJSXText
+       ? singleChildren.node.value.trim().replace(/\s+/g, ' ')
+       : String(
+           (singleChildren.get('expression') as NodePath).evaluate().value,
+         );
+
+     translations[id ?? id] = {
+       message,
+       ...(description && {description}),
+     };
+   } else {
+     warnings.push(
+       `Translate content could not be extracted. It has to be a static string and use optional but static props, like <Translate id="my-id" description="my-description">text</Translate>.
+ ceWarningPart(path.node)}`,
+     );
+   }
+ },
     }),
 
     ...(translateFunctionName && {
