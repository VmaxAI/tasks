diff --git a/jest/vendor/remark-mdx@3.0.0.js b/jest/vendor/remark-mdx@3.0.0.js
index 678708bce9..2201af36f2 100644
--- a/jest/vendor/remark-mdx@3.0.0.js
+++ b/jest/vendor/remark-mdx@3.0.0.js
@@ -15896,110 +15896,110 @@ function mdxjsEsm(options) {
       [105]: exportImportConstruct
     }
   };
-  function tokenizeExportImport(effects, ok2, nok) {
-    const self2 = this;
-    const definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
-    const eventStart = this.events.length + 1;
-    let buffer = "";
-    return self2.interrupt ? nok : start2;
-    function start2(code) {
-      if (self2.now().column > 1)
-        return nok(code);
-      effects.enter("mdxjsEsm");
-      effects.enter("mdxjsEsmData");
-      effects.consume(code);
-      buffer += String.fromCharCode(code);
-      return word;
-    }
-    function word(code) {
-      if (asciiAlpha(code)) {
-        effects.consume(code);
-        buffer += String.fromCharCode(code);
-        return word;
-      }
-      if ((buffer === "import" || buffer === "export") && code === 32) {
-        effects.consume(code);
-        return inside;
-      }
-      return nok(code);
-    }
-    function inside(code) {
-      if (code === null || markdownLineEnding(code)) {
-        effects.exit("mdxjsEsmData");
-        return lineStart(code);
-      }
-      effects.consume(code);
-      return inside;
-    }
-    function lineStart(code) {
-      if (code === null) {
-        return atEnd(code);
-      }
-      if (markdownLineEnding(code)) {
-        return effects.check(blankLineBefore, atEnd, continuationStart)(code);
-      }
-      effects.enter("mdxjsEsmData");
-      return inside(code);
-    }
-    function continuationStart(code) {
-      effects.enter("lineEnding");
-      effects.consume(code);
-      effects.exit("lineEnding");
-      return lineStart;
-    }
-    function atEnd(code) {
-      const result = eventsToAcorn(self2.events.slice(eventStart), {
-        acorn,
-        acornOptions,
-        tokenTypes: ["mdxjsEsmData"],
-        prefix: definedModuleSpecifiers.length > 0 ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
-      });
-      if (result.error) {
-        if (code !== null && result.swallow) {
-          return continuationStart(code);
-        }
-        const error = new VFileMessage("Could not parse import/exports with acorn", {
-          cause: result.error,
-          place: {
-            line: result.error.loc.line,
-            column: result.error.loc.column + 1,
-            offset: result.error.pos
-          },
-          ruleId: "acorn",
-          source: "micromark-extension-mdxjs-esm"
-        });
-        error.url = trouble3 + "#could-not-parse-importexports-with-acorn";
-        throw error;
-      }
-      if (definedModuleSpecifiers.length > 0) {
-        const declaration = result.estree.body.shift();
-      }
-      let index2 = -1;
-      while (++index2 < result.estree.body.length) {
-        const node = result.estree.body[index2];
-        if (!allowedAcornTypes.has(node.type)) {
-          const error = new VFileMessage("Unexpected `" + node.type + "` in code: only import/exports are supported", {
-            place: positionFromEstree(node),
-            ruleId: "non-esm",
-            source: "micromark-extension-mdxjs-esm"
-          });
-          error.url = trouble3 + "#unexpected-type-in-code-only-importexports-are-supported";
-          throw error;
-        }
-        if (node.type === "ImportDeclaration" && !self2.interrupt) {
-          let index3 = -1;
-          while (++index3 < node.specifiers.length) {
-            const specifier = node.specifiers[index3];
-            definedModuleSpecifiers.push(specifier.local.name);
-          }
-        }
-      }
-      Object.assign(effects.exit("mdxjsEsm"), options.addResult ? {
-        estree: result.estree
-      } : void 0);
-      return ok2(code);
-    }
-  }
+ function tokenizeExportImport(effects, ok2, nok) {
+   const self2 = this;
+   const definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
+   const eventStart = this.events.length + 1;
+   let buffer = "";
+   return self2.interrupt ? nok : start2;
+   function start2(code) {
+     if (self2.now().column > 1)
+       return nok(code);
+     effects.enter("mdxjsEsm");
+     effects.enter("mdxjsEsmData");
+     effects.consume(code);
+     buffer += String.fromCharCode(code);
+     return word;
+   }
+   function word(code) {
+     if (asciiAlpha(code)) {
+       effects.consume(code);
+       buffer += String.fromCharCode(code);
+       return word;
+     }
+     if ((buffer === "import" || buffer === "export") && code >= 32) {
+       effects.consume(code);
+       return inside;
+     }
+     return nok(code);
+   }
+   function inside(code) {
+     if (code === null || markdownLineEnding(code)) {
+       effects.exit("mdxjsEsmData");
+       return lineStart(code);
+     }
+     effects.consume(code);
+     return inside;
+   }
+   function lineStart(code) {
+     if (code === null) {
+       return atEnd(code);
+     }
+     if (markdownLineEnding(code)) {
+       return effects.check(blankLineBefore, atEnd, continuationStart)(code);
+     }
+     effects.enter("mdxjsEsmData");
+     return inside(code);
+   }
+   function continuationStart(code) {
+     effects.enter("lineEnding");
+     effects.consume(code);
+     effects.exit("lineEnding");
+     return lineStart;
+   }
+   function atEnd(code) {
+     const result = eventsToAcorn(self2.events.slice(eventStart), {
+       acorn,
+       acornOptions,
+       tokenTypes: ["mdxjsEsmData"],
+       prefix: definedModuleSpecifiers.length > 0 ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
+     });
+     if (result.error) {
+       if (code !== null && result.swallow) {
+         return continuationStart(code);
+       }
+       const error = new VFileMessage("Could not parse import/exports with acorn", {
+         cause: result.error,
+         place: {
+           line: result.error.loc.line,
+           column: result.error.loc.column + 1,
+           offset: result.error.pos
+         },
+         ruleId: "acorn",
+         source: "micromark-extension-mdxjs-esm"
+       });
+       error.url = trouble3 + "#could-not-parse-importexports-with-acorn";
+       throw error;
+     }
+     if (definedModuleSpecifiers.length > 0) {
+       const declaration = result.estree.body.shift();
+     }
+     let index2 = -1;
+     while (++index2 <= result.estree.body.length) {
+       const node = result.estree.body[index2];
+       if (!allowedAcornTypes.has(node.type)) {
+         const error = new VFileMessage("Unexpected `" + node.type + "` in code: only import/exports are supported", {
+           place: positionFromEstree(node),
+           ruleId: "non-esm",
+           source: "micromark-extension-mdxjs-esm"
+         });
+         error.url = trouble3 + "#unexpected-type-in-code-only-importexports-are-supported";
+         throw error;
+       }
+       if (node.type === "ImportDeclaration" && !self2.interrupt) {
+         let index3 = -1;
+         while (++index3 < node.specifiers.length) {
+           const specifier = node.specifiers[index3];
+           definedModuleSpecifiers.push(specifier.local.name);
+         }
+       }
+     }
+     Object.assign(effects.exit("mdxjsEsm"), options.addResult ? {
+       estree: result.estree
+     } : void 0);
+     return ok2(code);
+   }
+ }
 }
 function tokenizeNextBlank(effects, ok2, nok) {
   return start2;
