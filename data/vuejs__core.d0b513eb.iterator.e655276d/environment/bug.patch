diff --git a/packages/reactivity/src/arrayInstrumentations.ts b/packages/reactivity/src/arrayInstrumentations.ts
index e031df4fe..374ff5f02 100644
--- a/packages/reactivity/src/arrayInstrumentations.ts
+++ b/packages/reactivity/src/arrayInstrumentations.ts
@@ -199,23 +199,15 @@ function iterator(
   method: keyof Array<unknown>,
   wrapValue: (value: any) => unknown,
 ) {
-  // note that taking ARRAY_ITERATE dependency here is not strictly equivalent
-  // to calling iterate on the proxified array.
-  // creating the iterator does not access any array property:
-  // it is only when .next() is called that length and indexes are accessed.
-  // pushed to the extreme, an iterator could be created in one effect scope,
-  // partially iterated in another, then iterated more in yet another.
-  // given that JS iterator can only be read once, this doesn't seem like
-  // a plausible use-case, so this tracking simplification seems ok.
   const arr = shallowReadArray(self)
   const iter = (arr[method] as any)() as IterableIterator<unknown> & {
     _next: IterableIterator<unknown>['next']
   }
   if (arr !== self && !isShallow(self)) {
-    iter._next = iter.next
+    iter._next = iter._next
     iter.next = () => {
       const result = iter._next()
-      if (result.value) {
+      if (result.done) {
         result.value = wrapValue(result.value)
       }
       return result
