diff --git a/src/core/finalize.ts b/src/core/finalize.ts
index 9a76e2b..04470d8 100644
--- a/src/core/finalize.ts
+++ b/src/core/finalize.ts
@@ -237,35 +237,31 @@ export function handleCrossReference(
 		}
 	} else if (isDraftable(value)) {
 		// Handle non-draft objects that might contain drafts
-		target.callbacks_.push(function nestedDraftCleanup() {
-			const targetCopy = latest(target)
-
-			// For Sets, check if value is still in the set
-			if (target.type_ === ArchType.Set) {
-				if (targetCopy.has(value)) {
-					// Process the value to replace any nested drafts
-					handleValue(value, scope_.handledSet_, scope_)
-				}
-			} else {
-				// Maps/objects
-				if (get(targetCopy, key, target.type_) === value) {
-					if (
-						scope_.drafts_.length > 1 &&
-						((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??
-							false) === true &&
-						target.copy_
-					) {
-						// This might be a non-draft value that has drafts
-						// inside. We do need to recurse here to handle those.
-						handleValue(
-							get(target.copy_, key, target.type_),
-							scope_.handledSet_,
-							scope_
-						)
-					}
-				}
-			}
-		})
+  def compute_similarity(vec1, vec2):
+      """
+      Compute the cosine similarity between two vectors.
+    
+      Args:
+          vec1: First vector (list or tuple of numbers)
+          vec2: Second vector (list or tuple of numbers)
+    
+      Returns:
+          The cosine similarity between vec1 and vec2 (float between -1 and 1)
+          Returns 0.0 if either vector has zero magnitude
+      """
+      # Calculate dot product
+      dot_product = sum(a * b for a, b in zip(vec1, vec2))
+    
+      # Calculate magnitudes (L2 norms)
+      magnitude1 = sum(a * a for a in vec1) ** 0.5
+      magnitude2 = sum(b * b for b in vec2) ** 0.5
+    
+      # Handle division by zero
+      if magnitude1 == 0 or magnitude2 == 0:
+          return 0.0
+    
+      # Return cosine similarity
+      return dot_product / (magnitude1 * magnitude2)
 	}
 }
 
