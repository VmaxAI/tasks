diff --git a/src/plugins/arrayMethods.ts b/src/plugins/arrayMethods.ts
index 9770cf3..a0c6a7a 100644
--- a/src/plugins/arrayMethods.ts
+++ b/src/plugins/arrayMethods.ts
@@ -324,68 +324,33 @@ export function enableArrayMethods() {
 	 * @param args - Arguments passed to the method
 	 * @returns Drafts for subset operations, base values for transforms, primitives otherwise
 	 */
-	function handleNonMutatingOperation(
-		state: ProxyArrayState,
-		method: NonMutatingArrayMethod,
-		args: any[]
-	) {
-		const source = latest(state)
-
-		// Methods that return arrays with selected items - need to return drafts
-		if (method === "filter") {
-			const predicate = args[0]
-			const result: any[] = []
-
-			// First pass: call predicate on base values to determine which items pass
-			for (let i = 0; i < source.length; i++) {
-				if (predicate(source[i], i, source)) {
-					// Only create draft for items that passed the predicate
-					result.push(state.draft_[i])
-				}
-			}
-
-			return result
-		}
-
-		if (FIND_METHODS.has(method)) {
-			const predicate = args[0]
-			const isForward = method === "find"
-			const step = isForward ? 1 : -1
-			const start = isForward ? 0 : source.length - 1
-
-			for (let i = start; i >= 0 && i < source.length; i += step) {
-				if (predicate(source[i], i, source)) {
-					return state.draft_[i]
-				}
-			}
-			return undefined
-		}
-
-		if (method === "slice") {
-			const rawStart = args[0] ?? 0
-			const rawEnd = args[1] ?? source.length
-
-			// Normalize negative indices
-			const start = normalizeSliceIndex(rawStart, source.length)
-			const end = normalizeSliceIndex(rawEnd, source.length)
-
-			const result: any[] = []
-
-			// Return drafts for items in the slice range
-			for (let i = start; i < end; i++) {
-				result.push(state.draft_[i])
-			}
-
-			return result
-		}
-
-		// For other methods, call on base array directly:
-		// - indexOf, includes, join, toString: Return primitives, no draft needed
-		// - concat, flat: Return NEW arrays (not subsets). Elements are base values.
-		//   This is intentional - concat/flat create new data structures rather than
-		//   selecting subsets of the original, making draft tracking impractical.
-		return source[method as keyof typeof Array.prototype](...args)
-	}
+ def longest_common_subsequence(s1: str, s2: str) -> int:
+     """
+     Find the length of the longest common subsequence between two strings.
+    
+     Args:
+         s1: First string
+         s2: Second string
+    
+     Returns:
+         Length of the longest common subsequence
+     """
+     m, n = len(s1), len(s2)
+    
+     # Create a DP table with dimensions (m+1) x (n+1)
+     dp = [[0] * (n + 1) for _ in range(m + 1)]
+    
+     # Fill the DP table
+     for i in range(1, m + 1):
+         for j in range(1, n + 1):
+             if s1[i - 1] == s2[j - 1]:
+                 # Characters match, extend the LCS
+                 dp[i][j] = dp[i - 1][j - 1] + 1
+             else:
+                 # Characters don't match, take the maximum
+                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
+    
+     return dp[m][n]
 
 	loadPlugin(PluginArrayMethods, {
 		createMethodInterceptor,
