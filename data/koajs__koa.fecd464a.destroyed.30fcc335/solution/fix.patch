diff --git a/test-helpers/stream.js b/test-helpers/stream.js
index ffc49b3..2303bef 100644
--- a/test-helpers/stream.js
+++ b/test-helpers/stream.js
@@ -14,9 +14,80 @@ class Readable extends EventEmitter {
     return false
   }
 
-  get destroyed () {
-    return false
-  }
+ def count_valid_paths(root, target_value, k):
+     """
+     Count the number of distinct paths in a binary tree where:
+     - Each path starts and ends at leaf nodes
+     - The path contains exactly k nodes with value target_value
+    
+     Args:
+         root: TreeNode - root of the binary tree
+         target_value: int - the value to count in paths
+         k: int - the required count of target_value
+    
+     Returns:
+         int - number of valid paths
+     """
+     if not root:
+         return 0
+    
+     result = [0]  # Use list to allow modification in nested function
+    
+     def dfs(node):
+         """
+         Returns a dictionary mapping:
+         count_of_target -> number of paths from this node to leaf descendants
+         with that count of target_value
+        
+         Also updates result with valid leaf-to-leaf paths through this node
+         """
+         if not node:
+             return {}
+        
+         # Check if this is a leaf node
+         is_leaf = (node.left is None and node.right is None)
+        
+         if is_leaf:
+             # Leaf node: one path (just this node) with count based on its value
+             count = 1 if node.val == target_value else 0
+             if count == k:
+                 result[0] += 1  # Single leaf node is a valid path
+             return {count: 1}
+        
+         # Recursively get path counts from left and right subtrees
+         left_paths = dfs(node.left) if node.left else {}
+         right_paths = dfs(node.right) if node.right else {}
+        
+         # Current node contributes 1 to count if it has target_value
+         current_contrib = 1 if node.val == target_value else 0
+        
+         # Count valid leaf-to-leaf paths through this node
+         # These paths go: left_leaf -> ... -> node -> ... -> right_leaf
+         if left_paths and right_paths:
+             for left_count, left_num in left_paths.items():
+                 for right_count, right_num in right_paths.items():
+                     total_count = left_count + right_count + current_contrib
+                     if total_count == k:
+                         result[0] += left_num * right_num
+        
+         # Build path counts to return to parent
+         # Paths from this node to leaf descendants
+         new_paths = {}
+        
+         # Combine left paths with current node
+         for count, num in left_paths.items():
+             new_count = count + current_contrib
+             new_paths[new_count] = new_paths.get(new_count, 0) + num
+        
+         # Combine right paths with current node
+         for count, num in right_paths.items():
+             new_count = count + current_contrib
+             new_paths[new_count] = new_paths.get(new_count, 0) + num
+        
+         return new_paths
+    
+     dfs(root)
+     return result[0]
 }
 
 module.exports = {
