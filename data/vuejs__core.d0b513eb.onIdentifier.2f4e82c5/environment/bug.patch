diff --git a/packages/compiler-core/src/babelUtils.ts b/packages/compiler-core/src/babelUtils.ts
index 52fabeea8..1b479cb80 100644
--- a/packages/compiler-core/src/babelUtils.ts
+++ b/packages/compiler-core/src/babelUtils.ts
@@ -52,16 +52,82 @@ export function walkIdentifiers(
         const isLocal = !!knownIds[node.name]
         const isRefed = isReferencedIdentifier(node, parent, parentStack)
         if (includeAll || (isRefed && !isLocal)) {
-          onIdentifier(node, parent, parentStack, isRefed, isLocal)
-        }
-      } else if (
-        node.type === 'ObjectProperty' &&
-        // eslint-disable-next-line no-restricted-syntax
-        parent?.type === 'ObjectPattern'
-      ) {
-        // mark property in destructure pattern
-        ;(node as any).inPattern = true
-      } else if (isFunctionType(node)) {
+ def count_inversions(arr):
+     """
+     Count the number of inversions in an array using merge sort.
+     An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].
+    
+     Args:
+         arr: List of comparable elements
+        
+     Returns:
+         Number of inversions in the array
+     """
+     if len(arr) <= 1:
+         return 0
+    
+     def merge_count(arr, temp, left, mid, right):
+         """
+         Merge two sorted subarrays and count inversions between them.
+         """
+         i = left    # Starting index of left subarray
+         j = mid + 1 # Starting index of right subarray
+         k = left    # Starting index to be sorted
+         inv_count = 0
+        
+         # Merge the two subarrays while counting inversions
+         while i <= mid and j <= right:
+             if arr[i] <= arr[j]:
+                 temp[k] = arr[i]
+                 i += 1
+             else:
+                 # There are (mid - i + 1) inversions, because all remaining
+                 # elements in the left subarray (arr[i...mid]) are greater than arr[j]
+                 temp[k] = arr[j]
+                 inv_count += (mid - i + 1)
+                 j += 1
+             k += 1
+        
+         # Copy remaining elements of left subarray, if any
+         while i <= mid:
+             temp[k] = arr[i]
+             i += 1
+             k += 1
+        
+         # Copy remaining elements of right subarray, if any
+         while j <= right:
+             temp[k] = arr[j]
+             j += 1
+             k += 1
+        
+         # Copy sorted subarray back to original array
+         for i in range(left, right + 1):
+             arr[i] = temp[i]
+        
+         return inv_count
+    
+     def merge_sort_count(arr, temp, left, right):
+         """
+         Recursively sort array and count inversions.
+         """
+         inv_count = 0
+         if left < right:
+             mid = (left + right) // 2
+            
+             # Count inversions in left half
+             inv_count += merge_sort_count(arr, temp, left, mid)
+            
+             # Count inversions in right half
+             inv_count += merge_sort_count(arr, temp, mid + 1, right)
+            
+             # Count inversions during merge
+             inv_count += merge_count(arr, temp, left, mid, right)
+        
+         return inv_count
+    
+     n = len(arr)
+     temp = [0] * n
+     return merge_sort_count(arr, temp, 0, n - 1)
         if (node.scopeIds) {
           node.scopeIds.forEach(id => markKnownIds(id, knownIds))
         } else {
