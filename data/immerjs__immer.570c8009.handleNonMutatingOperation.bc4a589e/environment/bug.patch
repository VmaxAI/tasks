diff --git a/src/plugins/arrayMethods.ts b/src/plugins/arrayMethods.ts
index 9770cf3..76c3c44 100644
--- a/src/plugins/arrayMethods.ts
+++ b/src/plugins/arrayMethods.ts
@@ -324,68 +324,45 @@ export function enableArrayMethods() {
 	 * @param args - Arguments passed to the method
 	 * @returns Drafts for subset operations, base values for transforms, primitives otherwise
 	 */
-	function handleNonMutatingOperation(
-		state: ProxyArrayState,
-		method: NonMutatingArrayMethod,
-		args: any[]
-	) {
-		const source = latest(state)
-
-		// Methods that return arrays with selected items - need to return drafts
-		if (method === "filter") {
-			const predicate = args[0]
-			const result: any[] = []
-
-			// First pass: call predicate on base values to determine which items pass
-			for (let i = 0; i < source.length; i++) {
-				if (predicate(source[i], i, source)) {
-					// Only create draft for items that passed the predicate
-					result.push(state.draft_[i])
-				}
-			}
-
-			return result
-		}
-
-		if (FIND_METHODS.has(method)) {
-			const predicate = args[0]
-			const isForward = method === "find"
-			const step = isForward ? 1 : -1
-			const start = isForward ? 0 : source.length - 1
-
-			for (let i = start; i >= 0 && i < source.length; i += step) {
-				if (predicate(source[i], i, source)) {
-					return state.draft_[i]
-				}
-			}
-			return undefined
-		}
-
-		if (method === "slice") {
-			const rawStart = args[0] ?? 0
-			const rawEnd = args[1] ?? source.length
-
-			// Normalize negative indices
-			const start = normalizeSliceIndex(rawStart, source.length)
-			const end = normalizeSliceIndex(rawEnd, source.length)
-
-			const result: any[] = []
-
-			// Return drafts for items in the slice range
-			for (let i = start; i < end; i++) {
-				result.push(state.draft_[i])
-			}
-
-			return result
-		}
-
-		// For other methods, call on base array directly:
-		// - indexOf, includes, join, toString: Return primitives, no draft needed
-		// - concat, flat: Return NEW arrays (not subsets). Elements are base values.
-		//   This is intentional - concat/flat create new data structures rather than
-		//   selecting subsets of the original, making draft tracking impractical.
-		return source[method as keyof typeof Array.prototype](...args)
-	}
+ def is_valid_tree(n: int, edges: list[list[int]]) -> bool:
+     """
+     Determine if an undirected graph is a valid tree.
+    
+     Args:
+         n: Number of nodes (labeled from 0 to n-1)
+         edges: List of edges where each edge is [u, v]
+    
+     Returns:
+         True if the graph is a valid tree, False otherwise
+     """
+     # A tree with n nodes must have exactly n-1 edges
+     if len(edges) != n - 1:
+         return False
+    
+     # Edge case: empty tree
+     if n == 0:
+         return True
+    
+     # Build adjacency list
+     graph = [[] for _ in range(n)]
+     for u, v in edges:
+         graph[u].append(v)
+         graph[v].append(u)
+    
+     # BFS to check if all nodes are connected
+     visited = set()
+     queue = [0]
+     visited.add(0)
+    
+     while queue:
+         node = queue.pop(0)
+         for neighbor in graph[node]:
+             if neighbor not in visited:
+                 visited.add(neighbor)
+                 queue.append(neighbor)
+    
+     # All nodes should be visited if the graph is connected
+     return len(visited) == n
 
 	loadPlugin(PluginArrayMethods, {
 		createMethodInterceptor,
