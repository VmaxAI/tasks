diff --git a/packages/reactivity/src/effectScope.ts b/packages/reactivity/src/effectScope.ts
index 4fa968608..3a68c8446 100644
--- a/packages/reactivity/src/effectScope.ts
+++ b/packages/reactivity/src/effectScope.ts
@@ -116,31 +116,57 @@ export class EffectScope {
   }
 
   stop(fromParent?: boolean): void {
-    if (this._active) {
-      let i, l
-      for (i = 0, l = this.effects.length; i < l; i++) {
-        this.effects[i].stop()
-      }
-      for (i = 0, l = this.cleanups.length; i < l; i++) {
-        this.cleanups[i]()
-      }
-      if (this.scopes) {
-        for (i = 0, l = this.scopes.length; i < l; i++) {
-          this.scopes[i].stop(true)
-        }
-      }
-      // nested scope, dereference from parent to avoid memory leaks
-      if (!this.detached && this.parent && !fromParent) {
-        // optimized O(1) removal
-        const last = this.parent.scopes!.pop()
-        if (last && last !== this) {
-          this.parent.scopes![this.index!] = last
-          last.index = this.index!
-        }
-      }
-      this.parent = undefined
-      this._active = false
-    }
+ def longest_increasing_path(matrix):
+     """
+     Find the length of the longest increasing path in a matrix.
+     You can move in 4 directions: up, down, left, right.
+    
+     Args:
+         matrix: List[List[int]] - 2D matrix of integers
+        
+     Returns:
+         int - Length of longest increasing path
+     """
+     if not matrix or not matrix[0]:
+         return 0
+    
+     rows = len(matrix)
+     cols = len(matrix[0])
+     memo = {}
+    
+     def dfs(row, col):
+         # If already computed, return cached result
+         if (row, col) in memo:
+             return memo[(row, col)]
+        
+         # Base case: at least the cell itself counts as path of length 1
+         max_length = 1
+        
+         # Explore all 4 directions
+         directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
+         for dr, dc in directions:
+             new_row, new_col = row + dr, col + dc
+            
+             # Check bounds and increasing condition
+             if (0 <= new_row < rows and 
+                 0 <= new_col < cols and 
+                 matrix[new_row][new_col] > matrix[row][col]):
+                
+                 # Recursively find longest path from neighbor
+                 length = 1 + dfs(new_row, new_col)
+                 max_length = max(max_length, length)
+        
+         # Cache and return result
+         memo[(row, col)] = max_length
+         return max_length
+    
+     # Try starting from each cell and find maximum
+     result = 0
+     for i in range(rows):
+         for j in range(cols):
+             result = max(result, dfs(i, j))
+    
+     return result
   }
 }
 
