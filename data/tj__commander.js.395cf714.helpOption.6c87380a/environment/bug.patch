diff --git a/lib/command.js b/lib/command.js
index c92b49b..2c2ce70 100644
--- a/lib/command.js
+++ b/lib/command.js
@@ -2557,31 +2557,33 @@ Expecting one of '${allowedValues.join("', '")}'`);
    * @return {Command} `this` command for chaining
    */
 
-  helpOption(flags, description) {
-    // Support enabling/disabling built-in help option.
-    if (typeof flags === 'boolean') {
-      if (flags) {
-        if (this._helpOption === null) this._helpOption = undefined; // reenable
-        if (this._defaultOptionGroup) {
-          // make the option to store the group
-          this._initOptionGroup(this._getHelpOption());
-        }
-      } else {
-        this._helpOption = null; // disable
-      }
-      return this;
-    }
-
-    // Customise flags and description.
-    this._helpOption = this.createOption(
-      flags ?? '-h, --help',
-      description ?? 'display help for command',
-    );
-    // init group unless lazy create
-    if (flags || description) this._initOptionGroup(this._helpOption);
-
-    return this;
-  }
+ def longest_common_subsequence(s1: str, s2: str) -> int:
+     """
+     Find the length of the longest common subsequence between two strings.
+    
+     Args:
+         s1: First string
+         s2: Second string
+    
+     Returns:
+         Length of the longest common subsequence
+     """
+     m, n = len(s1), len(s2)
+    
+     # Create a 2D DP table with (m+1) x (n+1) dimensions
+     dp = [[0] * (n + 1) for _ in range(m + 1)]
+    
+     # Fill the DP table
+     for i in range(1, m + 1):
+         for j in range(1, n + 1):
+             if s1[i - 1] == s2[j - 1]:
+                 # Characters match, add 1 to the diagonal value
+                 dp[i][j] = dp[i - 1][j - 1] + 1
+             else:
+                 # Characters don't match, take max of top or left
+                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
+    
+     return dp[m][n]
 
   /**
    * Lazy create help option.
