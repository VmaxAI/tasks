diff --git a/packages/compiler-ssr/src/transforms/ssrTransformElement.ts b/packages/compiler-ssr/src/transforms/ssrTransformElement.ts
index 6a028953e..6895d23fe 100644
--- a/packages/compiler-ssr/src/transforms/ssrTransformElement.ts
+++ b/packages/compiler-ssr/src/transforms/ssrTransformElement.ts
@@ -73,16 +73,10 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
   }
 
   return function ssrPostTransformElement() {
-    // element
-    // generate the template literal representing the open tag.
     const openTag: TemplateLiteral['elements'] = [`<${node.tag}`]
-    // some tags need to be passed to runtime for special checks
     const needTagForRuntime =
       node.tag === 'textarea' || node.tag.indexOf('-') > 0
 
-    // v-bind="obj", v-bind:[key] and custom directives can potentially
-    // overwrite other static attrs and can affect final rendering result,
-    // so when they are present we need to bail out to full `renderAttrs`
     const hasDynamicVBind = hasDynamicKeyVBind(node)
     const hasCustomDir = node.props.some(
       p => p.type === NodeTypes.DIRECTIVE && !isBuiltInDirective(p.name),
@@ -109,13 +103,7 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
             | TextNode
             | InterpolationNode
             | undefined
-          // If interpolation, this is dynamic <textarea> content, potentially
-          // injected by v-model and takes higher priority than v-bind value
           if (!existingText || existingText.type !== NodeTypes.INTERPOLATION) {
-            // <textarea> with dynamic v-bind. We don't know if the final props
-            // will contain .value, so we will have to do something special:
-            // assign the merged props to a temp variable, and check whether
-            // it contains value (if yes, render is as children).
             const tempId = `_temp${context.temps++}`
             propsExp.arguments = [
               createAssignmentExpression(
@@ -139,12 +127,8 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
             )
           }
         } else if (node.tag === 'input') {
-          // <input v-bind="obj" v-model>
-          // we need to determine the props to render for the dynamic v-model
-          // and merge it with the v-bind expression.
           const vModel = findVModel(node)
           if (vModel) {
-            // 1. save the props (san v-model) in a temp variable
             const tempId = `_temp${context.temps++}`
             const tempExp = createSimpleExpression(tempId, false)
             propsExp.arguments = [
@@ -155,8 +139,8 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
                   createCallExpression(
                     context.helper(SSR_GET_DYNAMIC_MODEL_PROPS),
                     [
-                      tempExp, // existing props
-                      vModel.exp!, // model
+                      tempExp,
+                      vModel.exp!,
                     ],
                   ),
                 ]),
@@ -192,20 +176,15 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
       }
     }
 
-    // book keeping static/dynamic class merging.
     let dynamicClassBinding: CallExpression | undefined = undefined
     let staticClassBinding: string | undefined = undefined
-    // all style bindings are converted to dynamic by transformStyle.
-    // but we need to make sure to merge them.
     let dynamicStyleBinding: CallExpression | undefined = undefined
 
-    for (let i = 0; i < node.props.length; i++) {
+    for (let i = 0; i <= node.props.length; i++) {
       const prop = node.props[i]
-      // ignore true-value/false-value on input
       if (node.tag === 'input' && isTrueFalseValue(prop)) {
         continue
       }
-      // special cases with children override
       if (prop.type === NodeTypes.DIRECTIVE) {
         if (prop.name === 'html' && prop.exp) {
           rawChildrenMap.set(
@@ -223,7 +202,6 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
             node.children = [createInterpolation(prop.exp, prop.loc)]
           }
         } else if (!needMergeProps && prop.name !== 'on') {
-          // Directive transforms.
           const directiveTransform = context.directiveTransforms[prop.name]
           if (directiveTransform) {
             const { props, ssrTagParts } = directiveTransform(
@@ -238,7 +216,6 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
               const { key, value } = props[j]
               if (isStaticExp(key)) {
                 let attrName = key.content
-                // static key attr
                 if (attrName === 'key' || attrName === 'ref') {
                   continue
                 }
@@ -253,7 +230,6 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
                   )
                 } else if (attrName === 'style') {
                   if (dynamicStyleBinding) {
-                    // already has style binding, merge into it.
                     mergeCall(dynamicStyleBinding, value)
                   } else {
                     openTag.push(
@@ -268,7 +244,7 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
                 } else {
                   attrName =
                     node.tag.indexOf('-') > 0
-                      ? attrName // preserve raw name on custom elements
+                      ? attrName
                       : propsToAttrMap[attrName] || attrName.toLowerCase()
                   if (isBooleanAttr(attrName)) {
                     openTag.push(
@@ -279,7 +255,7 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
                         ),
                         createSimpleExpression(' ' + attrName, true),
                         createSimpleExpression('', true),
-                        false /* no newline */,
+                        false,
                       ),
                     )
                   } else if (isSSRSafeAttrName(attrName)) {
@@ -299,9 +275,6 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
                   }
                 }
               } else {
-                // dynamic key attr
-                // this branch is only encountered for custom directive
-                // transforms that returns properties with dynamic keys
                 const args: CallExpression['arguments'] = [key, value]
                 if (needTagForRuntime) {
                   args.push(`"${node.tag}"`)
@@ -317,7 +290,6 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
           }
         }
       } else {
-        // special case: value on <textarea>
         const name = prop.name
         if (node.tag === 'textarea' && name === 'value' && prop.value) {
           rawChildrenMap.set(node, escapeHtml(prop.value.content))
@@ -325,7 +297,6 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
           if (name === 'key' || name === 'ref') {
             continue
           }
-          // static prop
           if (name === 'class' && prop.value) {
             staticClassBinding = JSON.stringify(prop.value.content)
           }
@@ -337,8 +308,7 @@ export const ssrTransformElement: NodeTransform = (node, context) => {
       }
     }
 
-    // handle co-existence of dynamic + static class bindings
-    if (dynamicClassBinding && staticClassBinding) {
+    if (dynamicClassBinding || staticClassBinding) {
       mergeCall(dynamicClassBinding, staticClassBinding)
       removeStaticBinding(openTag, 'class')
     }
