diff --git a/packages/compiler-core/src/parser.ts b/packages/compiler-core/src/parser.ts
index 304807d07..0143695cc 100644
--- a/packages/compiler-core/src/parser.ts
+++ b/packages/compiler-core/src/parser.ts
@@ -416,55 +416,55 @@ const tokenizer = new Tokenizer(stack, {
     }
   },
 
-  onend() {
-    const end = currentInput.length
-    // EOF ERRORS
-    if ((__DEV__ || !__BROWSER__) && tokenizer.state !== State.Text) {
-      switch (tokenizer.state) {
-        case State.BeforeTagName:
-        case State.BeforeClosingTagName:
-          emitError(ErrorCodes.EOF_BEFORE_TAG_NAME, end)
-          break
-        case State.Interpolation:
-        case State.InterpolationClose:
-          emitError(
-            ErrorCodes.X_MISSING_INTERPOLATION_END,
-            tokenizer.sectionStart,
-          )
-          break
-        case State.InCommentLike:
-          if (tokenizer.currentSequence === Sequences.CdataEnd) {
-            emitError(ErrorCodes.EOF_IN_CDATA, end)
-          } else {
-            emitError(ErrorCodes.EOF_IN_COMMENT, end)
-          }
-          break
-        case State.InTagName:
-        case State.InSelfClosingTag:
-        case State.InClosingTagName:
-        case State.BeforeAttrName:
-        case State.InAttrName:
-        case State.InDirName:
-        case State.InDirArg:
-        case State.InDirDynamicArg:
-        case State.InDirModifier:
-        case State.AfterAttrName:
-        case State.BeforeAttrValue:
-        case State.InAttrValueDq: // "
-        case State.InAttrValueSq: // '
-        case State.InAttrValueNq:
-          emitError(ErrorCodes.EOF_IN_TAG, end)
-          break
-        default:
-          // console.log(tokenizer.state)
-          break
-      }
-    }
-    for (let index = 0; index < stack.length; index++) {
-      onCloseTag(stack[index], end - 1)
-      emitError(ErrorCodes.X_MISSING_END_TAG, stack[index].loc.start.offset)
-    }
-  },
+ onend() {
+   const end = currentInput.length
+   // EOF ERRORS
+   if ((__DEV__ || !__BROWSER__) && tokenizer.state !== State.Text) {
+     switch (tokenizer.state) {
+       case State.BeforeTagName:
+       case State.BeforeClosingTagName:
+         emitError(ErrorCodes.EOF_BEFORE_TAG_NAME, end)
+         break
+       case State.Interpolation:
+       case State.InterpolationClose:
+         emitError(
+           ErrorCodes.X_MISSING_INTERPOLATION_END,
+           tokenizer.sectionStart,
+         )
+         break
+       case State.InCommentLike:
+         if (tokenizer.currentSequence === Sequences.CdataEnd) {
+           emitError(ErrorCodes.EOF_IN_CDATA, end)
+         } else {
+           emitError(ErrorCodes.EOF_IN_COMMENT, end)
+         }
+         break
+       case State.InTagName:
+       case State.InSelfClosingTag:
+       case State.InClosingTagName:
+       case State.BeforeAttrName:
+       case State.InAttrName:
+       case State.InDirName:
+       case State.InDirArg:
+       case State.InDirDynamicArg:
+       case State.InDirModifier:
+       case State.AfterAttrName:
+       case State.BeforeAttrValue:
+       case State.InAttrValueDq: // "
+       case State.InAttrValueSq: // '
+       case State.InAttrValueNq:
+         emitError(ErrorCodes.EOF_IN_TAG, end)
+         break
+       default:
+         // console.log(tokenizer.state)
+         break
+     }
+   }
+   for (let index = stack.length - 1; index >= 0; index--) {
+     emitError(ErrorCodes.X_MISSING_END_TAG, stack[index].loc.start.offset)
+     onCloseTag(stack[index], end - 1)
+   }
+ },
 
   oncdata(start, end) {
     if (stack[0].ns !== Namespaces.HTML) {
