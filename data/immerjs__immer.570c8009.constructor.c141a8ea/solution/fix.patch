diff --git a/src/plugins/mapset.ts b/src/plugins/mapset.ts
index 3c59eab..d03b5fc 100644
--- a/src/plugins/mapset.ts
+++ b/src/plugins/mapset.ts
@@ -24,153 +24,66 @@ export function enableMapSet() {
 	class DraftMap extends Map {
 		[DRAFT_STATE]: MapState
 
-		constructor(target: AnyMap, parent?: ImmerState) {
-			super()
-			this[DRAFT_STATE] = {
-				type_: ArchType.Map,
-				parent_: parent,
-				scope_: parent ? parent.scope_ : getCurrentScope()!,
-				modified_: false,
-				finalized_: false,
-				copy_: undefined,
-				assigned_: undefined,
-				base_: target,
-				draft_: this as any,
-				isManual_: false,
-				revoked_: false,
-				callbacks_: []
-			}
-		}
-
-		get size(): number {
-			return latest(this[DRAFT_STATE]).size
-		}
-
-		has(key: any): boolean {
-			return latest(this[DRAFT_STATE]).has(key)
-		}
-
-		set(key: any, value: any) {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (!latest(state).has(key) || latest(state).get(key) !== value) {
-				prepareMapCopy(state)
-				markChanged(state)
-				state.assigned_!.set(key, true)
-				state.copy_!.set(key, value)
-				state.assigned_!.set(key, true)
-				handleCrossReference(state, key, value)
-			}
-			return this
-		}
-
-		delete(key: any): boolean {
-			if (!this.has(key)) {
-				return false
-			}
-
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			prepareMapCopy(state)
-			markChanged(state)
-			if (state.base_.has(key)) {
-				state.assigned_!.set(key, false)
-			} else {
-				state.assigned_!.delete(key)
-			}
-			state.copy_!.delete(key)
-			return true
-		}
-
-		clear() {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			if (latest(state).size) {
-				prepareMapCopy(state)
-				markChanged(state)
-				state.assigned_ = new Map()
-				each(state.base_, key => {
-					state.assigned_!.set(key, false)
-				})
-				state.copy_!.clear()
-			}
-		}
-
-		forEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {
-			const state: MapState = this[DRAFT_STATE]
-			latest(state).forEach((_value: any, key: any, _map: any) => {
-				cb.call(thisArg, this.get(key), key, this)
-			})
-		}
-
-		get(key: any): any {
-			const state: MapState = this[DRAFT_STATE]
-			assertUnrevoked(state)
-			const value = latest(state).get(key)
-			if (state.finalized_ || !isDraftable(value)) {
-				return value
-			}
-			if (value !== state.base_.get(key)) {
-				return value // either already drafted or reassigned
-			}
-			// despite what it looks, this creates a draft only once, see above condition
-			const draft = createProxy(state.scope_, value, state, key)
-			prepareMapCopy(state)
-			state.copy_!.set(key, draft)
-			return draft
-		}
-
-		keys(): IterableIterator<any> {
-			return latest(this[DRAFT_STATE]).keys()
-		}
-
-		values(): IterableIterator<any> {
-			const iterator = this.keys()
-			return {
-				[Symbol.iterator]: () => this.values(),
-				next: () => {
-					const r = iterator.next()
-					/* istanbul ignore next */
-					if (r.done) return r
-					const value = this.get(r.value)
-					return {
-						done: false,
-						value
-					}
-				}
-			} as any
-		}
-
-		entries(): IterableIterator<[any, any]> {
-			const iterator = this.keys()
-			return {
-				[Symbol.iterator]: () => this.entries(),
-				next: () => {
-					const r = iterator.next()
-					/* istanbul ignore next */
-					if (r.done) return r
-					const value = this.get(r.value)
-					return {
-						done: false,
-						value: [r.value, value]
-					}
-				}
-			} as any
-		}
-
-		[Symbol.iterator]() {
-			return this.entries()
-		}
-	}
-
-	function proxyMap_<T extends AnyMap>(
-		target: T,
-		parent?: ImmerState
-	): [T, MapState] {
-		// @ts-ignore
-		const map = new DraftMap(target, parent)
-		return [map as any, map[DRAFT_STATE]]
-	}
+  def longest_increasing_path(matrix):
+      """
+      Find the length of the longest strictly increasing path in a matrix.
+    
+      You can move up, down, left, or right from each cell.
+    
+      Args:
+          matrix: A 2D list of integers
+        
+      Returns:
+          The length of the longest strictly increasing path
+        
+      Examples:
+          >>> longest_increasing_path([[9,9,4],[6,6,8],[2,1,1]])
+          4
+          >>> longest_increasing_path([[3,4,5],[3,2,6],[2,2,1]])
+          4
+          >>> longest_increasing_path([[1]])
+          1
+      """
+      if not matrix or not matrix[0]:
+          return 0
+    
+      rows = len(matrix)
+      cols = len(matrix[0])
+      memo = {}
+    
+      def dfs(row, col):
+          # If already computed, return cached result
+          if (row, col) in memo:
+              return memo[(row, col)]
+        
+          # Base case: minimum path length is 1 (the cell itself)
+          max_length = 1
+        
+          # Try all 4 directions: up, down, left, right
+          directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
+        
+          for dr, dc in directions:
+              new_row, new_col = row + dr, col + dc
+            
+              # Check if the new position is valid and has a greater value
+              if (0 <= new_row < rows and 
+                  0 <= new_col < cols and 
+                  matrix[new_row][new_col] > matrix[row][col]):
+                
+                  # Recursively find the longest path from the new position
+                  max_length = max(max_length, 1 + dfs(new_row, new_col))
+        
+          # Cache the result
+          memo[(row, col)] = max_length
+          return max_length
+    
+      # Try starting from each cell and find the maximum path length
+      result = 0
+      for i in range(rows):
+          for j in range(cols):
+              result = max(result, dfs(i, j))
+    
+      return result
 
 	function prepareMapCopy(state: MapState) {
 		if (!state.copy_) {
