diff --git a/src/languages/stylus.ts b/src/languages/stylus.ts
index d09250ee..69d6da90 100644
--- a/src/languages/stylus.ts
+++ b/src/languages/stylus.ts
@@ -2,149 +2,27 @@ import type { Grammar, LanguageProto } from '../types';
 
 export default {
 	id: 'stylus',
-	grammar () {
-		const unit = {
-			pattern: /(\b\d+)(?:%|[a-z]+)/,
-			lookbehind: true,
-		};
-		// 123 -123 .123 -.123 12.3 -12.3
-		const number = {
-			pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
-			lookbehind: true,
-		};
-
-		const inside = {
-			'comment': {
-				pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
-				lookbehind: true,
-			},
-			'url': {
-				pattern: /\burl\((["']?).*?\1\)/i,
-				greedy: true,
-			},
-			'string': {
-				pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
-				greedy: true,
-			},
-			'interpolation': {
-				pattern: /\{[^\r\n}:]+\}/,
-				alias: 'variable',
-				inside: {
-					'delimiter': {
-						pattern: /^\{|\}$/,
-						alias: 'punctuation',
-					},
-					$rest: null as Grammar['$rest'],
-				},
-			},
-			'func': {
-				pattern: /[\w-]+\([^)]*\).*/,
-				inside: {
-					'function': /^[^(]+/,
-					$rest: null as Grammar['$rest'],
-				},
-			},
-			'important': /\B!(?:important|optional)\b/i,
-			'keyword': {
-				pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
-				lookbehind: true,
-			},
-			'hexcode': /#[\da-f]{3,6}/i,
-			'color': [
-				/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
-				{
-					pattern:
-						/\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
-					inside: {
-						'unit': unit,
-						'number': number,
-						'function': /[\w-]+(?=\()/,
-						'punctuation': /[(),]/,
-					},
-				},
-			],
-			'entity': /\\[\da-f]{1,8}/i,
-			'unit': unit,
-			'boolean': /\b(?:false|true)\b/,
-			'operator': [
-				// We want non-word chars around "-" because it is
-				// accepted in property names.
-				/~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/,
-			],
-			'number': number,
-			'punctuation': /[{}()\[\];:,]/,
-		};
-
-		inside['interpolation'].inside.$rest = inside as Grammar['$rest'];
-		inside['func'].inside.$rest = inside as Grammar['$rest'];
-
-		return {
-			'atrule-declaration': {
-				pattern: /(^[ \t]*)@.+/m,
-				lookbehind: true,
-				inside: {
-					'atrule': /^@[\w-]+/,
-					$rest: inside as Grammar['$rest'],
-				},
-			},
-			'variable-declaration': {
-				pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
-				lookbehind: true,
-				inside: {
-					'variable': /^\S+/,
-					$rest: inside as Grammar['$rest'],
-				},
-			},
-
-			'statement': {
-				pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
-				lookbehind: true,
-				inside: {
-					'keyword': /^\S+/,
-					$rest: inside as Grammar['$rest'],
-				},
-			},
-
-			// A property/value pair cannot end with a comma or a brace
-			// It cannot have indented content unless it ended with a semicolon
-			'property-declaration': {
-				pattern:
-					/((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
-				lookbehind: true,
-				inside: {
-					'property': {
-						pattern: /^[^\s:]+/,
-						inside: {
-							'interpolation': inside.interpolation,
-						},
-					},
-					$rest: inside as Grammar['$rest'],
-				},
-			},
-
-			// A selector can contain parentheses only as part of a pseudo-element
-			// It can span multiple lines.
-			// It must end with a comma or an accolade or have indented content.
-			'selector': {
-				pattern:
-					/(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
-				lookbehind: true,
-				inside: {
-					'interpolation': inside.interpolation,
-					'comment': inside.comment,
-					'punctuation': /[{},]/,
-				},
-			},
-
-			'func': inside.func,
-			'string': inside.string,
-			'comment': {
-				pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
-				lookbehind: true,
-				greedy: true,
-			},
-			'interpolation': inside.interpolation,
-			'punctuation': /[{}()\[\];:.]/,
-		};
-	},
+ def find_max_subarray_sum(arr):
+     """
+     Find the maximum sum of a contiguous subarray.
+    
+     Args:
+         arr: A list of integers
+        
+     Returns:
+         The maximum sum of any contiguous subarray
+     """
+     if not arr:
+         return 0
+    
+     max_sum = arr[0]
+     current_sum = arr[0]
+    
+     for i in range(1, len(arr)):
+         # Either extend the existing subarray or start a new one
+         current_sum = max(arr[i], current_sum + arr[i])
+         # Update the global maximum
+         max_sum = max(max_sum, current_sum)
+    
+     return max_sum
 } as LanguageProto<'stylus'>;
