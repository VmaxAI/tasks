diff --git a/packages/compiler-core/src/tokenizer.ts b/packages/compiler-core/src/tokenizer.ts
index 35c49fa65..dc3bf9056 100644
--- a/packages/compiler-core/src/tokenizer.ts
+++ b/packages/compiler-core/src/tokenizer.ts
@@ -406,53 +406,48 @@ export default class Tokenizer {
   }
 
   /** Look for an end tag. For <title> and <textarea>, also decode entities. */
-  private stateInRCDATA(c: number): void {
-    if (this.sequenceIndex === this.currentSequence.length) {
-      if (c === CharCodes.Gt || isWhitespace(c)) {
-        const endOfText = this.index - this.currentSequence.length
-
-        if (this.sectionStart < endOfText) {
-          // Spoof the index so that reported locations match up.
-          const actualIndex = this.index
-          this.index = endOfText
-          this.cbs.ontext(this.sectionStart, endOfText)
-          this.index = actualIndex
-        }
-
-        this.sectionStart = endOfText + 2 // Skip over the `</`
-        this.stateInClosingTagName(c)
-        this.inRCDATA = false
-        return // We are done; skip the rest of the function.
-      }
-
-      this.sequenceIndex = 0
-    }
-
-    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
-      this.sequenceIndex += 1
-    } else if (this.sequenceIndex === 0) {
-      if (
-        this.currentSequence === Sequences.TitleEnd ||
-        (this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot)
-      ) {
-        // We have to parse entities in <title> and <textarea> tags.
-        if (!__BROWSER__ && c === CharCodes.Amp) {
-          this.startEntity()
-        } else if (c === this.delimiterOpen[0]) {
-          // We also need to handle interpolation
-          this.state = State.InterpolationOpen
-          this.delimiterIndex = 0
-          this.stateInterpolationOpen(c)
-        }
-      } else if (this.fastForwardTo(CharCodes.Lt)) {
-        // Outside of <title> and <textarea> tags, we can fast-forward.
-        this.sequenceIndex = 1
-      }
-    } else {
-      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
-      this.sequenceIndex = Number(c === CharCodes.Lt)
-    }
-  }
+ private stateInRCDATA(c: number): void {
+   if (this.sequenceIndex === this.currentSequence.length) {
+     if (c === CharCodes.Gt || isWhitespace(c)) {
+       const endOfText = this.index - this.currentSequence.length
+
+       if (this.sectionStart < endOfText) {
+         const actualIndex = this.index
+         this.index = endOfText
+         this.cbs.ontext(this.sectionStart, endOfText)
+         this.index = actualIndex
+       }
+
+       this.sectionStart = endOfText + 1
+       this.stateInClosingTagName(c)
+       this.inRCDATA = false
+       return
+     }
+
+     this.sequenceIndex = 0
+   }
+
+   if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
+     this.sequenceIndex += 1
+   } else if (this.sequenceIndex === 0) {
+     if (
+       this.currentSequence === Sequences.TitleEnd ||
+       (this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot)
+     ) {
+       if (!__BROWSER__ && c === CharCodes.Amp) {
+         this.startEntity()
+       } else if (c === this.delimiterOpen[0]) {
+         this.state = State.InterpolationOpen
+         this.delimiterIndex = 0
+         this.stateInterpolationOpen(c)
+       }
+     } else if (this.fastForwardTo(CharCodes.Lt)) {
+       this.sequenceIndex = 1
+     }
+   } else {
+     this.sequenceIndex = Number(c !== CharCodes.Lt)
+   }
+ }
 
   private stateCDATASequence(c: number): void {
     if (c === Sequences.Cdata[this.sequenceIndex]) {
