diff --git a/src/core/finalize.ts b/src/core/finalize.ts
index 9a76e2b..e2fe8ec 100644
--- a/src/core/finalize.ts
+++ b/src/core/finalize.ts
@@ -237,35 +237,32 @@ export function handleCrossReference(
 		}
 	} else if (isDraftable(value)) {
 		// Handle non-draft objects that might contain drafts
-		target.callbacks_.push(function nestedDraftCleanup() {
-			const targetCopy = latest(target)
-
-			// For Sets, check if value is still in the set
-			if (target.type_ === ArchType.Set) {
-				if (targetCopy.has(value)) {
-					// Process the value to replace any nested drafts
-					handleValue(value, scope_.handledSet_, scope_)
-				}
-			} else {
-				// Maps/objects
-				if (get(targetCopy, key, target.type_) === value) {
-					if (
-						scope_.drafts_.length > 1 &&
-						((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??
-							false) === true &&
-						target.copy_
-					) {
-						// This might be a non-draft value that has drafts
-						// inside. We do need to recurse here to handle those.
-						handleValue(
-							get(target.copy_, key, target.type_),
-							scope_.handledSet_,
-							scope_
-						)
-					}
-				}
-			}
-		})
+  def max_subarray_sum(arr):
+      """
+      Find the maximum sum of a contiguous subarray.
+    
+      Args:
+          arr: List of integers
+        
+      Returns:
+          Maximum sum of any contiguous subarray
+      """
+      if not arr:
+          return 0
+    
+      # Initialize with the first element
+      max_current = arr[0]
+      max_global = arr[0]
+    
+      # Iterate through the rest of the array
+      for i in range(1, len(arr)):
+          # Either extend the existing subarray or start a new one
+          max_current = max(arr[i], max_current + arr[i])
+        
+          # Update the global maximum if current is better
+          max_global = max(max_global, max_current)
+    
+      return max_global
 	}
 }
 
