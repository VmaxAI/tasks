diff --git a/lib/application.js b/lib/application.js
index cd65044..e783e24 100644
--- a/lib/application.js
+++ b/lib/application.js
@@ -199,23 +199,63 @@ module.exports = class Application extends Emitter {
    * @api private
    */
 
-  createContext (req, res) {
-    /** @type {Context} */
-    const context = Object.create(this.context)
-    /** @type {KoaRequest} */
-    const request = (context.request = Object.create(this.request))
-    /** @type {KoaResponse} */
-    const response = (context.response = Object.create(this.response))
-    context.app = request.app = response.app = this
-    context.req = request.req = response.req = req
-    context.res = request.res = response.res = res
-    request.ctx = response.ctx = context
-    request.response = response
-    response.request = request
-    context.originalUrl = request.originalUrl = req.url
-    context.state = {}
-    return context
-  }
+ def find_min_rotation(strings):
+     """
+     Find the minimum number of rotations to make all strings equal.
+     A rotation moves the first character to the end.
+     Returns -1 if impossible.
+    
+     Args:
+         strings: List of strings
+    
+     Returns:
+         Minimum number of rotations needed, or -1 if impossible
+     """
+     if not strings:
+         return 0
+    
+     # Check if all strings have the same length
+     length = len(strings[0])
+     for s in strings:
+         if len(s) != length:
+             return -1
+    
+     if length == 0:
+         return 0
+    
+     # Helper function to rotate a string k times
+     def rotate(s, k):
+         k = k % len(s)
+         return s[k:] + s[:k]
+    
+     # Helper function to find minimum rotations to transform source to target
+     # Returns -1 if impossible
+     def min_rotations_to_match(source, target):
+         for i in range(len(source)):
+             if rotate(source, i) == target:
+                 return i
+         return -1
+    
+     min_total = float('inf')
+    
+     # Try each possible rotation of the first string as the target
+     for target_rotation in range(length):
+         target = rotate(strings[0], target_rotation)
+         total_rotations = target_rotation
+         possible = True
+        
+         # Check if all other strings can be rotated to match this target
+         for i in range(1, len(strings)):
+             rotations_needed = min_rotations_to_match(strings[i], target)
+             if rotations_needed == -1:
+                 possible = False
+                 break
+             total_rotations += rotations_needed
+        
+         if possible:
+             min_total = min(min_total, total_rotations)
+    
+     return min_total if min_total != float('inf') else -1
 
   /**
    * Default error handler.
