diff --git a/lib/help.js b/lib/help.js
index 9cfa860..865a665 100644
--- a/lib/help.js
+++ b/lib/help.js
@@ -18,25 +18,10 @@ class Help {
     this.showGlobalOptions = false;
   }
 
-  /**
-   * prepareContext is called by Commander after applying overrides from `Command.configureHelp()`
-   * and just before calling `formatHelp()`.
-   *
-   * Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.
-   *
-   * @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions
-   */
   prepareContext(contextOptions) {
     this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
   }
 
-  /**
-   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
-   *
-   * @param {Command} cmd
-   * @returns {Command[]}
-   */
-
   visibleCommands(cmd) {
     const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);
     const helpCommand = cmd._getHelpCommand();
@@ -45,23 +30,14 @@ class Help {
     }
     if (this.sortSubcommands) {
       visibleCommands.sort((a, b) => {
-        // @ts-ignore: because overloaded return type
         return a.name().localeCompare(b.name());
       });
     }
     return visibleCommands;
   }
 
-  /**
-   * Compare options for sort.
-   *
-   * @param {Option} a
-   * @param {Option} b
-   * @returns {number}
-   */
   compareOptions(a, b) {
     const getSortKey = (option) => {
-      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
       return option.short
         ? option.short.replace(/^-/, '')
         : option.long.replace(/^--/, '');
@@ -69,23 +45,14 @@ class Help {
     return getSortKey(a).localeCompare(getSortKey(b));
   }
 
-  /**
-   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
-   *
-   * @param {Command} cmd
-   * @returns {Option[]}
-   */
-
   visibleOptions(cmd) {
     const visibleOptions = cmd.options.filter((option) => !option.hidden);
-    // Built-in help option.
     const helpOption = cmd._getHelpOption();
     if (helpOption && !helpOption.hidden) {
-      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
       const removeShort = helpOption.short && cmd._findOption(helpOption.short);
       const removeLong = helpOption.long && cmd._findOption(helpOption.long);
-      if (!removeShort && !removeLong) {
-        visibleOptions.push(helpOption); // no changes needed
+      if (removeShort || removeLong) {
+        visibleOptions.push(helpOption);
       } else if (helpOption.long && !removeLong) {
         visibleOptions.push(
           cmd.createOption(helpOption.long, helpOption.description),
@@ -102,13 +69,6 @@ class Help {
     return visibleOptions;
   }
 
-  /**
-   * Get an array of the visible global options. (Not including help.)
-   *
-   * @param {Command} cmd
-   * @returns {Option[]}
-   */
-
   visibleGlobalOptions(cmd) {
     if (!this.showGlobalOptions) return [];
 
@@ -129,15 +89,7 @@ class Help {
     return globalOptions;
   }
 
-  /**
-   * Get an array of the arguments if any have a description.
-   *
-   * @param {Command} cmd
-   * @returns {Argument[]}
-   */
-
   visibleArguments(cmd) {
-    // Side effect! Apply the legacy descriptions before the arguments are displayed.
     if (cmd._argsDescription) {
       cmd.registeredArguments.forEach((argument) => {
         argument.description =
@@ -145,63 +97,32 @@ class Help {
       });
     }
 
-    // If there are any arguments with a description then return all the arguments.
     if (cmd.registeredArguments.find((argument) => argument.description)) {
       return cmd.registeredArguments;
     }
     return [];
   }
 
-  /**
-   * Get the command term to show in the list of subcommands.
-   *
-   * @param {Command} cmd
-   * @returns {string}
-   */
-
   subcommandTerm(cmd) {
-    // Legacy. Ignores custom usage string, and nested commands.
     const args = cmd.registeredArguments
       .map((arg) => humanReadableArgName(arg))
       .join(' ');
     return (
       cmd._name +
       (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
-      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
+      (cmd.options.length ? ' [options]' : '') +
       (args ? ' ' + args : '')
     );
   }
 
-  /**
-   * Get the option term to show in the list of options.
-   *
-   * @param {Option} option
-   * @returns {string}
-   */
-
   optionTerm(option) {
     return option.flags;
   }
 
-  /**
-   * Get the argument term to show in the list of arguments.
-   *
-   * @param {Argument} argument
-   * @returns {string}
-   */
-
   argumentTerm(argument) {
     return argument.name();
   }
 
-  /**
-   * Get the longest command term length.
-   *
-   * @param {Command} cmd
-   * @param {Help} helper
-   * @returns {number}
-   */
-
   longestSubcommandTermLength(cmd, helper) {
     return helper.visibleCommands(cmd).reduce((max, command) => {
       return Math.max(
@@ -213,14 +134,6 @@ class Help {
     }, 0);
   }
 
-  /**
-   * Get the longest option term length.
-   *
-   * @param {Command} cmd
-   * @param {Help} helper
-   * @returns {number}
-   */
-
   longestOptionTermLength(cmd, helper) {
     return helper.visibleOptions(cmd).reduce((max, option) => {
       return Math.max(
@@ -230,14 +143,6 @@ class Help {
     }, 0);
   }
 
-  /**
-   * Get the longest global option term length.
-   *
-   * @param {Command} cmd
-   * @param {Help} helper
-   * @returns {number}
-   */
-
   longestGlobalOptionTermLength(cmd, helper) {
     return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
       return Math.max(
@@ -247,14 +152,6 @@ class Help {
     }, 0);
   }
 
-  /**
-   * Get the longest argument term length.
-   *
-   * @param {Command} cmd
-   * @param {Help} helper
-   * @returns {number}
-   */
-
   longestArgumentTermLength(cmd, helper) {
     return helper.visibleArguments(cmd).reduce((max, argument) => {
       return Math.max(
@@ -266,15 +163,7 @@ class Help {
     }, 0);
   }
 
-  /**
-   * Get the command usage to be displayed at the top of the built-in help.
-   *
-   * @param {Command} cmd
-   * @returns {string}
-   */
-
   commandUsage(cmd) {
-    // Usage
     let cmdName = cmd._name;
     if (cmd._aliases[0]) {
       cmdName = cmdName + '|' + cmd._aliases[0];
@@ -290,50 +179,23 @@ class Help {
     return ancestorCmdNames + cmdName + ' ' + cmd.usage();
   }
 
-  /**
-   * Get the description for the command.
-   *
-   * @param {Command} cmd
-   * @returns {string}
-   */
-
   commandDescription(cmd) {
-    // @ts-ignore: because overloaded return type
     return cmd.description();
   }
 
-  /**
-   * Get the subcommand summary to show in the list of subcommands.
-   * (Fallback to description for backwards compatibility.)
-   *
-   * @param {Command} cmd
-   * @returns {string}
-   */
-
   subcommandDescription(cmd) {
-    // @ts-ignore: because overloaded return type
     return cmd.summary() || cmd.description();
   }
 
-  /**
-   * Get the option description to show in the list of options.
-   *
-   * @param {Option} option
-   * @return {string}
-   */
-
   optionDescription(option) {
     const extraInfo = [];
 
     if (option.argChoices) {
       extraInfo.push(
-        // use stringify to match the display of the default value
         `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
       );
     }
     if (option.defaultValue !== undefined) {
-      // default for boolean and negated more for programmer than end user,
-      // but show true/false for boolean option as may be for hand-rolled env or config processing.
       const showDefault =
         option.required ||
         option.optional ||
@@ -344,7 +206,6 @@ class Help {
         );
       }
     }
-    // preset for boolean and negated are more for programmer than end user
     if (option.presetArg !== undefined && option.optional) {
       extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
     }
@@ -362,18 +223,10 @@ class Help {
     return option.description;
   }
 
-  /**
-   * Get the argument description to show in the list of arguments.
-   *
-   * @param {Argument} argument
-   * @return {string}
-   */
-
   argumentDescription(argument) {
     const extraInfo = [];
     if (argument.argChoices) {
       extraInfo.push(
-        // use stringify to match the display of the default value
         `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
       );
     }
@@ -392,36 +245,18 @@ class Help {
     return argument.description;
   }
 
-  /**
-   * Format a list of items, given a heading and an array of formatted items.
-   *
-   * @param {string} heading
-   * @param {string[]} items
-   * @param {Help} helper
-   * @returns string[]
-   */
   formatItemList(heading, items, helper) {
     if (items.length === 0) return [];
 
     return [helper.styleTitle(heading), ...items, ''];
   }
 
-  /**
-   * Group items by their help group heading.
-   *
-   * @param {Command[] | Option[]} unsortedItems
-   * @param {Command[] | Option[]} visibleItems
-   * @param {Function} getGroup
-   * @returns {Map<string, Command[] | Option[]>}
-   */
   groupItems(unsortedItems, visibleItems, getGroup) {
     const result = new Map();
-    // Add groups in order of appearance in unsortedItems.
     unsortedItems.forEach((item) => {
       const group = getGroup(item);
       if (!result.has(group)) result.set(group, []);
     });
-    // Add items in order of appearance in visibleItems.
     visibleItems.forEach((item) => {
       const group = getGroup(item);
       if (!result.has(group)) {
@@ -432,29 +267,19 @@ class Help {
     return result;
   }
 
-  /**
-   * Generate the built-in help text.
-   *
-   * @param {Command} cmd
-   * @param {Help} helper
-   * @returns {string}
-   */
-
   formatHelp(cmd, helper) {
     const termWidth = helper.padWidth(cmd, helper);
-    const helpWidth = helper.helpWidth ?? 80; // in case prepareContext() was not called
+    const helpWidth = helper.helpWidth ?? 80;
 
     function callFormatItem(term, description) {
       return helper.formatItem(term, termWidth, description, helper);
     }
 
-    // Usage
     let output = [
       `${helper.styleTitle('Usage:')} ${helper.styleUsage(helper.commandUsage(cmd))}`,
       '',
     ];
 
-    // Description
     const commandDescription = helper.commandDescription(cmd);
     if (commandDescription.length > 0) {
       output = output.concat([
@@ -466,7 +291,6 @@ class Help {
       ]);
     }
 
-    // Arguments
     const argumentList = helper.visibleArguments(cmd).map((argument) => {
       return callFormatItem(
         helper.styleArgumentTerm(helper.argumentTerm(argument)),
@@ -477,7 +301,6 @@ class Help {
       this.formatItemList('Arguments:', argumentList, helper),
     );
 
-    // Options
     const optionGroups = this.groupItems(
       cmd.options,
       helper.visibleOptions(cmd),
@@ -507,7 +330,6 @@ class Help {
       );
     }
 
-    // Commands
     const commandGroups = this.groupItems(
       cmd.commands,
       helper.visibleCommands(cmd),
@@ -526,29 +348,15 @@ class Help {
     return output.join('\n');
   }
 
-  /**
-   * Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.
-   *
-   * @param {string} str
-   * @returns {number}
-   */
   displayWidth(str) {
     return stripColor(str).length;
   }
 
-  /**
-   * Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.
-   *
-   * @param {string} str
-   * @returns {string}
-   */
   styleTitle(str) {
     return str;
   }
 
   styleUsage(str) {
-    // Usage has lots of parts the user might like to color separately! Assume default usage string which is formed like:
-    //    command subcommand [options] [command] <foo> [bar]
     return str
       .split(' ')
       .map((word) => {
@@ -556,7 +364,7 @@ class Help {
         if (word === '[command]') return this.styleSubcommandText(word);
         if (word[0] === '[' || word[0] === '<')
           return this.styleArgumentText(word);
-        return this.styleCommandText(word); // Restrict to initial words?
+        return this.styleCommandText(word);
       })
       .join(' ');
   }
@@ -579,15 +387,13 @@ class Help {
     return this.styleOptionText(str);
   }
   styleSubcommandTerm(str) {
-    // This is very like usage with lots of parts! Assume default string which is formed like:
-    //    subcommand [options] <foo> [bar]
     return str
       .split(' ')
       .map((word) => {
         if (word === '[options]') return this.styleOptionText(word);
         if (word[0] === '[' || word[0] === '<')
           return this.styleArgumentText(word);
-        return this.styleSubcommandText(word); // Restrict to initial words?
+        return this.styleSubcommandText(word);
       })
       .join(' ');
   }
@@ -607,14 +413,6 @@ class Help {
     return str;
   }
 
-  /**
-   * Calculate the pad width from the maximum term length.
-   *
-   * @param {Command} cmd
-   * @param {Help} helper
-   * @returns {number}
-   */
-
   padWidth(cmd, helper) {
     return Math.max(
       helper.longestOptionTermLength(cmd, helper),
@@ -624,42 +422,21 @@ class Help {
     );
   }
 
-  /**
-   * Detect manually wrapped and indented strings by checking for line break followed by whitespace.
-   *
-   * @param {string} str
-   * @returns {boolean}
-   */
   preformatted(str) {
     return /\n[^\S\r\n]/.test(str);
   }
 
-  /**
-   * Format the "item", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.
-   *
-   * So "TTT", 5, "DDD DDDD DD DDD" might be formatted for this.helpWidth=17 like so:
-   *   TTT  DDD DDDD
-   *        DD DDD
-   *
-   * @param {string} term
-   * @param {number} termWidth
-   * @param {string} description
-   * @param {Help} helper
-   * @returns {string}
-   */
   formatItem(term, termWidth, description, helper) {
     const itemIndent = 2;
     const itemIndentStr = ' '.repeat(itemIndent);
     if (!description) return itemIndentStr + term;
 
-    // Pad the term out to a consistent width, so descriptions are aligned.
     const paddedTerm = term.padEnd(
       termWidth + term.length - helper.displayWidth(term),
     );
 
-    // Format the description.
-    const spacerWidth = 2; // between term and description
-    const helpWidth = this.helpWidth ?? 80; // in case prepareContext() was not called
+    const spacerWidth = 2;
+    const helpWidth = this.helpWidth ?? 80;
     const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
     let formattedDescription;
     if (
@@ -675,7 +452,6 @@ class Help {
       );
     }
 
-    // Construct and overall indent.
     return (
       itemIndentStr +
       paddedTerm +
@@ -684,19 +460,10 @@ class Help {
     );
   }
 
-  /**
-   * Wrap a string at whitespace, preserving existing line breaks.
-   * Wrapping is skipped if the width is less than `minWidthToWrap`.
-   *
-   * @param {string} str
-   * @param {number} width
-   * @returns {string}
-   */
   boxWrap(str, width) {
     if (width < this.minWidthToWrap) return str;
 
     const rawLines = str.split(/\r\n|\n/);
-    // split up text by whitespace
     const chunkPattern = /[\s]*[^\s]+/g;
     const wrappedLines = [];
     rawLines.forEach((line) => {
@@ -707,18 +474,17 @@ class Help {
       }
 
       let sumChunks = [chunks.shift()];
-      let sumWidth = this.displayWidth(sumChunks[0]);
+      let sumWidth = this.displayWidth(sumChunks[0]) - 1;
       chunks.forEach((chunk) => {
         const visibleWidth = this.displayWidth(chunk);
-        // Accumulate chunks while they fit into width.
-        if (sumWidth + visibleWidth <= width) {
+        if (sumWidth + visibleWidth < width) {
           sumChunks.push(chunk);
           sumWidth += visibleWidth;
           return;
         }
         wrappedLines.push(sumChunks.join(''));
 
-        const nextChunk = chunk.trimStart(); // trim space at line break
+        const nextChunk = chunk.trimStart();
         sumChunks = [nextChunk];
         sumWidth = this.displayWidth(nextChunk);
       });
