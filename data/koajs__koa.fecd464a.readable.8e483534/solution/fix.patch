diff --git a/test-helpers/stream.js b/test-helpers/stream.js
index ffc49b3..909edee 100644
--- a/test-helpers/stream.js
+++ b/test-helpers/stream.js
@@ -6,9 +6,71 @@ class Readable extends EventEmitter {
   pipe () {}
   read () {}
   destroy () {}
-  get readable () {
-    return true
-  }
+ def find_minimum_window(s: str, t: str) -> str:
+     """
+     Finds the minimum window substring in s which contains all characters in t.
+    
+     Args:
+         s: The source string
+         t: The target string containing characters to find
+    
+     Returns:
+         The minimum window substring, or empty string if no such window exists
+     """
+     if not s or not t or len(s) < len(t):
+         return ""
+    
+     # Count characters needed from t
+     char_count = {}
+     for char in t:
+         char_count[char] = char_count.get(char, 0) + 1
+    
+     required = len(char_count)  # Number of unique characters in t
+     formed = 0  # Number of unique characters in current window with desired frequency
+    
+     # Dictionary to keep count of characters in current window
+     window_counts = {}
+    
+     # Left and right pointers
+     left = 0
+     right = 0
+    
+     # Result: (window length, left, right)
+     min_len = float('inf')
+     min_left = 0
+     min_right = 0
+    
+     while right < len(s):
+         # Add character from the right to the window
+         char = s[right]
+         window_counts[char] = window_counts.get(char, 0) + 1
+        
+         # Check if the frequency of current character matches desired count in t
+         if char in char_count and window_counts[char] == char_count[char]:
+             formed += 1
+        
+         # Try to contract the window until it ceases to be 'desirable'
+         while left <= right and formed == required:
+             # Update result if this window is smaller
+             if right - left + 1 < min_len:
+                 min_len = right - left + 1
+                 min_left = left
+                 min_right = right
+            
+             # The character at the left pointer is no longer part of the window
+             char = s[left]
+             window_counts[char] -= 1
+             if char in char_count and window_counts[char] < char_count[char]:
+                 formed -= 1
+            
+             # Move left pointer ahead for next iteration
+             left += 1
+        
+         # Expand the window by moving right pointer
+         right += 1
+    
+     # Return the minimum window or empty string if no valid window found
+     return "" if min_len == float('inf') else s[min_left:min_right + 1]
 
   get readableObjectMode () {
     return false
