diff --git a/src/plugins/arrayMethods.ts b/src/plugins/arrayMethods.ts
index 9770cf3..813d0fa 100644
--- a/src/plugins/arrayMethods.ts
+++ b/src/plugins/arrayMethods.ts
@@ -324,68 +324,38 @@ export function enableArrayMethods() {
 	 * @param args - Arguments passed to the method
 	 * @returns Drafts for subset operations, base values for transforms, primitives otherwise
 	 */
-	function handleNonMutatingOperation(
-		state: ProxyArrayState,
-		method: NonMutatingArrayMethod,
-		args: any[]
-	) {
-		const source = latest(state)
-
-		// Methods that return arrays with selected items - need to return drafts
-		if (method === "filter") {
-			const predicate = args[0]
-			const result: any[] = []
-
-			// First pass: call predicate on base values to determine which items pass
-			for (let i = 0; i < source.length; i++) {
-				if (predicate(source[i], i, source)) {
-					// Only create draft for items that passed the predicate
-					result.push(state.draft_[i])
-				}
-			}
-
-			return result
-		}
-
-		if (FIND_METHODS.has(method)) {
-			const predicate = args[0]
-			const isForward = method === "find"
-			const step = isForward ? 1 : -1
-			const start = isForward ? 0 : source.length - 1
-
-			for (let i = start; i >= 0 && i < source.length; i += step) {
-				if (predicate(source[i], i, source)) {
-					return state.draft_[i]
-				}
-			}
-			return undefined
-		}
-
-		if (method === "slice") {
-			const rawStart = args[0] ?? 0
-			const rawEnd = args[1] ?? source.length
-
-			// Normalize negative indices
-			const start = normalizeSliceIndex(rawStart, source.length)
-			const end = normalizeSliceIndex(rawEnd, source.length)
-
-			const result: any[] = []
-
-			// Return drafts for items in the slice range
-			for (let i = start; i < end; i++) {
-				result.push(state.draft_[i])
-			}
-
-			return result
-		}
-
-		// For other methods, call on base array directly:
-		// - indexOf, includes, join, toString: Return primitives, no draft needed
-		// - concat, flat: Return NEW arrays (not subsets). Elements are base values.
-		//   This is intentional - concat/flat create new data structures rather than
-		//   selecting subsets of the original, making draft tracking impractical.
-		return source[method as keyof typeof Array.prototype](...args)
-	}
+ def count_substrings_with_k_distinct(s: str, k: int) -> int:
+     """
+     Count the number of substrings in s that have exactly k distinct characters.
+    
+     Args:
+         s: The input string
+         k: The number of distinct characters required
+        
+     Returns:
+         The count of substrings with exactly k distinct characters
+     """
+     if k <= 0 or k > len(s):
+         return 0
+    
+     count = 0
+     n = len(s)
+    
+     # Iterate through all possible substrings
+     for i in range(n):
+         distinct_chars = set()
+         for j in range(i, n):
+             # Add current character to the set
+             distinct_chars.add(s[j])
+            
+             # Check if we have exactly k distinct characters
+             if len(distinct_chars) == k:
+                 count += 1
+             # If we have more than k distinct characters, no need to continue
+             elif len(distinct_chars) > k:
+                 break
+    
+     return count
 
 	loadPlugin(PluginArrayMethods, {
 		createMethodInterceptor,
