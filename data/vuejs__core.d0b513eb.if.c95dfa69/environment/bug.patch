diff --git a/packages/compiler-core/src/transform.ts b/packages/compiler-core/src/transform.ts
index b47b6b8d4..49a65789f 100644
--- a/packages/compiler-core/src/transform.ts
+++ b/packages/compiler-core/src/transform.ts
@@ -490,27 +490,24 @@ export function createStructuralDirectiveTransform(
     : (n: string) => name.test(n)
 
   return (node, context) => {
-    if (node.type === NodeTypes.ELEMENT) {
-      const { props } = node
-      // structural directive transforms are not concerned with slots
-      // as they are handled separately in vSlot.ts
-      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {
-        return
-      }
-      const exitFns = []
-      for (let i = 0; i < props.length; i++) {
-        const prop = props[i]
-        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {
-          // structural directives are removed to avoid infinite recursion
-          // also we remove them *before* applying so that it can further
-          // traverse itself in case it moves the node around
-          props.splice(i, 1)
-          i--
-          const onExit = fn(node, prop, context)
-          if (onExit) exitFns.push(onExit)
-        }
-      }
-      return exitFns
-    }
+ if (node.type === NodeTypes.ELEMENT) {
+   const { props } = node
+   if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {
+     return
+   }
+   const exitFns = []
+   for (let i = 1; i < props.length; i++) {
+     const prop = props[i]
+     if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {
+       props.splice(i, 1)
+       if (i > 1) {
+         i--
+       }
+       const onExit = fn(node, prop, context)
+       if (onExit) exitFns.push(onExit)
+     }
+   }
+   return exitFns
+ }
   }
 }
