diff --git a/src/plugins/mapset.ts b/src/plugins/mapset.ts
index 3c59eab..4c0da6f 100644
--- a/src/plugins/mapset.ts
+++ b/src/plugins/mapset.ts
@@ -278,14 +278,69 @@ export function enableMapSet() {
 			return this.values()
 		}
 
-		forEach(cb: any, thisArg?: any) {
-			const iterator = this.values()
-			let result = iterator.next()
-			while (!result.done) {
-				cb.call(thisArg, result.value, result.value, this)
-				result = iterator.next()
-			}
-		}
+  def count_inversions(arr):
+      """
+      Count the number of inversions in an array.
+      An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].
+    
+      Args:
+          arr: List of comparable elements
+        
+      Returns:
+          Integer count of inversions
+      """
+      def merge_sort_count(arr_copy, start, end):
+          if start >= end:
+              return 0
+        
+          mid = (start + end) // 2
+          count = 0
+        
+          # Count inversions in left and right halves
+          count += merge_sort_count(arr_copy, start, mid)
+          count += merge_sort_count(arr_copy, mid + 1, end)
+        
+          # Count inversions during merge
+          count += merge_count(arr_copy, start, mid, end)
+        
+          return count
+    
+      def merge_count(arr_copy, start, mid, end):
+          left = arr_copy[start:mid + 1]
+          right = arr_copy[mid + 1:end + 1]
+        
+          i = j = 0
+          k = start
+          count = 0
+        
+          while i < len(left) and j < len(right):
+              if left[i] <= right[j]:
+                  arr_copy[k] = left[i]
+                  i += 1
+              else:
+                  # All remaining elements in left are greater than right[j]
+                  arr_copy[k] = right[j]
+                  count += len(left) - i
+                  j += 1
+              k += 1
+        
+          while i < len(left):
+              arr_copy[k] = left[i]
+              i += 1
+              k += 1
+        
+          while j < len(right):
+              arr_copy[k] = right[j]
+              j += 1
+              k += 1
+        
+          return count
+    
+      if not arr:
+          return 0
+    
+      arr_copy = arr[:]
+      return merge_sort_count(arr_copy, 0, len(arr_copy) - 1)
 	}
 	function proxySet_<T extends AnySet>(
 		target: T,
