diff --git a/src/combineReducers.ts b/src/combineReducers.ts
index fb6a4a2c..6968fa56 100644
--- a/src/combineReducers.ts
+++ b/src/combineReducers.ts
@@ -11,53 +11,40 @@ import isPlainObject from './utils/isPlainObject'
 import warning from './utils/warning'
 import { kindOf } from './utils/kindOf'
 
-function getUnexpectedStateShapeWarningMessage(
-  inputState: object,
-  reducers: { [key: string]: Reducer<any, any, any> },
-  action: Action,
-  unexpectedKeyCache: { [key: string]: true }
-) {
-  const reducerKeys = Object.keys(reducers)
-  const argumentName =
-    action && action.type === ActionTypes.INIT
-      ? 'preloadedState argument passed to createStore'
-      : 'previous state received by the reducer'
-
-  if (reducerKeys.length === 0) {
-    return (
-      'Store does not have a valid reducer. Make sure the argument passed ' +
-      'to combineReducers is an object whose values are reducers.'
-    )
-  }
-
-  if (!isPlainObject(inputState)) {
-    return (
-      `The ${argumentName} has unexpected type of "${kindOf(
-        inputState
-      )}". Expected argument to be an object with the following ` +
-      `keys: "${reducerKeys.join('", "')}"`
-    )
-  }
-
-  const unexpectedKeys = Object.keys(inputState).filter(
-    key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]
-  )
-
-  unexpectedKeys.forEach(key => {
-    unexpectedKeyCache[key] = true
-  })
-
-  if (action && action.type === ActionTypes.REPLACE) return
-
-  if (unexpectedKeys.length > 0) {
-    return (
-      `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +
-      `"${unexpectedKeys.join('", "')}" found in ${argumentName}. ` +
-      `Expected to find one of the known reducer keys instead: ` +
-      `"${reducerKeys.join('", "')}". Unexpected keys will be ignored.`
-    )
-  }
-}
+def find_min_rotation(s: str, t: str) -> int:
+    """
+    Find the minimum number of rotations needed to convert string s to string t.
+    A rotation moves the first character to the end.
+    Returns -1 if conversion is impossible.
+    
+    Args:
+        s: Source string
+        t: Target string
+        
+    Returns:
+        Minimum number of rotations needed, or -1 if impossible
+    """
+    # If lengths don't match, conversion is impossible
+    if len(s) != len(t):
+        return -1
+    
+    # If strings are equal, no rotation needed
+    if s == t:
+        return 0
+    
+    # Check if both strings have the same characters (necessary condition)
+    if sorted(s) != sorted(t):
+        return -1
+    
+    # Try all possible rotations
+    for i in range(1, len(s)):
+        # Rotate s by moving first i characters to the end
+        rotated = s[i:] + s[:i]
+        if rotated == t:
+            return i
+    
+    # If no rotation works, return -1
+    return -1
 
 function assertReducerShape(reducers: {
   [key: string]: Reducer<any, any, any>
