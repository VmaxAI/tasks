diff --git a/lib/request.js b/lib/request.js
index be802f5..5d0aed6 100644
--- a/lib/request.js
+++ b/lib/request.js
@@ -673,16 +673,44 @@ module.exports = {
    * @api public
    */
 
-  get (field) {
-    const req = this.req
-    switch (field = field.toLowerCase()) {
-      case 'referer':
-      case 'referrer':
-        return req.headers.referrer || req.headers.referer || ''
-      default:
-        return req.headers[field] || ''
-    }
-  },
+ def get_min_max_at_depth(root, depth):
+     """
+     Returns a tuple (min_value, max_value) of node values at the specified depth.
+     If the depth doesn't exist, returns None.
+    
+     Args:
+         root: TreeNode or None
+         depth: int, 0-indexed (root is at depth 0)
+    
+     Returns:
+         tuple of (min_value, max_value) or None
+     """
+     if root is None:
+         return None
+    
+     if depth == 0:
+         return (root.val, root.val)
+    
+     # Use BFS to traverse the tree level by level
+     queue = [(root, 0)]  # (node, current_depth)
+     nodes_at_depth = []
+    
+     while queue:
+         node, current_depth = queue.pop(0)
+        
+         if current_depth == depth:
+             nodes_at_depth.append(node.val)
+         elif current_depth < depth:
+             # Only continue if we haven't reached the target depth yet
+             if node.left:
+                 queue.append((node.left, current_depth + 1))
+             if node.right:
+                 queue.append((node.right, current_depth + 1))
+    
+     if not nodes_at_depth:
+         return None
+    
+     return (min(nodes_at_depth), max(nodes_at_depth))
 
   /**
    * Inspect implementation.
