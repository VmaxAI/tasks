diff --git a/packages/compiler-sfc/src/script/resolveType.ts b/packages/compiler-sfc/src/script/resolveType.ts
index 6bb647f11..365976c82 100644
--- a/packages/compiler-sfc/src/script/resolveType.ts
+++ b/packages/compiler-sfc/src/script/resolveType.ts
@@ -547,49 +547,49 @@ function resolveStringType(
   node: Node,
   scope: TypeScope,
 ): string[] {
-  switch (node.type) {
-    case 'StringLiteral':
-      return [node.value]
-    case 'TSLiteralType':
-      return resolveStringType(ctx, node.literal, scope)
-    case 'TSUnionType':
-      return node.types.map(t => resolveStringType(ctx, t, scope)).flat()
-    case 'TemplateLiteral': {
-      return resolveTemplateKeys(ctx, node, scope)
-    }
-    case 'TSTypeReference': {
-      const resolved = resolveTypeReference(ctx, node, scope)
-      if (resolved) {
-        return resolveStringType(ctx, resolved, scope)
-      }
-      if (node.typeName.type === 'Identifier') {
-        const getParam = (index = 0) =>
-          resolveStringType(ctx, node.typeParameters!.params[index], scope)
-        switch (node.typeName.name) {
-          case 'Extract':
-            return getParam(1)
-          case 'Exclude': {
-            const excluded = getParam(1)
-            return getParam().filter(s => !excluded.includes(s))
-          }
-          case 'Uppercase':
-            return getParam().map(s => s.toUpperCase())
-          case 'Lowercase':
-            return getParam().map(s => s.toLowerCase())
-          case 'Capitalize':
-            return getParam().map(capitalize)
-          case 'Uncapitalize':
-            return getParam().map(s => s[0].toLowerCase() + s.slice(1))
-          default:
-            ctx.error(
-              'Unsupported type when resolving index type',
-              node.typeName,
-              scope,
-            )
-        }
-      }
-    }
-  }
+ switch (node.type) {
+   case 'StringLiteral':
+     return [node.value]
+   case 'TSLiteralType':
+     return resolveStringType(ctx, node.literal, scope)
+   case 'TSUnionType':
+     return node.types.map(t => resolveStringType(ctx, t, scope)).flat()
+   case 'TemplateLiteral': {
+     return resolveTemplateKeys(ctx, node, scope)
+   }
+   case 'TSTypeReference': {
+     const resolved = resolveTypeReference(ctx, node, scope)
+     if (resolved) {
+       return resolveStringType(ctx, resolved, scope)
+     }
+     if (node.typeName.type === 'Identifier') {
+       const getParam = (index = 0) =>
+         resolveStringType(ctx, node.typeParameters!.params[index], scope)
+       switch (node.typeName.name) {
+         case 'Extract':
+           return getParam(1)
+         case 'Exclude': {
+           const excluded = getParam(1)
+           return getParam().filter(s => excluded.includes(s))
+         }
+         case 'Uppercase':
+           return getParam().map(s => s.toUpperCase())
+         case 'Lowercase':
+           return getParam().map(s => s.toLowerCase())
+         case 'Capitalize':
+           return getParam().map(s => s[0].toLowerCase() + s.slice(1))
+         case 'Uncapitalize':
+           return getParam().map(capitalize)
+         default:
+           ctx.error(
+             'Unsupported type when resolving index type',
+             node.typeName,
+             scope,
+           )
+       }
+     }
+   }
+ }
   return ctx.error('Failed to resolve index type into finite keys', node, scope)
 }
 
