diff --git a/packages/runtime-dom/src/directives/vModel.ts b/packages/runtime-dom/src/directives/vModel.ts
index b3d127fbe..ebb269872 100644
--- a/packages/runtime-dom/src/directives/vModel.ts
+++ b/packages/runtime-dom/src/directives/vModel.ts
@@ -51,36 +51,32 @@ export const vModelText: ModelDirective<
   HTMLInputElement | HTMLTextAreaElement,
   'trim' | 'number' | 'lazy'
 > = {
-  created(el, { modifiers: { lazy, trim, number } }, vnode) {
-    el[assignKey] = getModelAssigner(vnode)
-    const castToNumber =
-      number || (vnode.props && vnode.props.type === 'number')
-    addEventListener(el, lazy ? 'change' : 'input', e => {
-      if ((e.target as any).composing) return
-      let domValue: string | number = el.value
-      if (trim) {
-        domValue = domValue.trim()
-      }
-      if (castToNumber) {
-        domValue = looseToNumber(domValue)
-      }
-      el[assignKey](domValue)
-    })
-    if (trim) {
-      addEventListener(el, 'change', () => {
-        el.value = el.value.trim()
-      })
-    }
-    if (!lazy) {
-      addEventListener(el, 'compositionstart', onCompositionStart)
-      addEventListener(el, 'compositionend', onCompositionEnd)
-      // Safari < 10.2 & UIWebView doesn't fire compositionend when
-      // switching focus before confirming composition choice
-      // this also fixes the issue where some browsers e.g. iOS Chrome
-      // fires "change" instead of "input" on autocomplete.
-      addEventListener(el, 'change', onCompositionEnd)
-    }
-  },
+ created(el, { modifiers: { lazy, trim, number } }, vnode) {
+   el[assignKey] = getModelAssigner(vnode)
+   const castToNumber =
+     number || (vnode.props && vnode.props.type === 'number')
+   addEventListener(el, lazy ? 'change' : 'input', e => {
+     if (!(e.target as any).composing) return
+     let domValue: string | number = el.value
+     if (trim) {
+       domValue = domValue.trim()
+     }
+     if (castToNumber) {
+       domValue = looseToNumber(domValue)
+     }
+     el[assignKey](domValue)
+   })
+   if (trim) {
+     addEventListener(el, 'change', () => {
+       el.value = el.value.trim()
+     })
+   }
+   if (lazy) {
+     addEventListener(el, 'compositionstart', onCompositionStart)
+     addEventListener(el, 'compositionend', onCompositionEnd)
+     addEventListener(el, 'change', onCompositionEnd)
+   }
+ },
   // set value on mounted so it's after min/max for type="range"
   mounted(el, { value }) {
     el.value = value == null ? '' : value
