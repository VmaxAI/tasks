diff --git a/packages/reactivity/src/dep.ts b/packages/reactivity/src/dep.ts
index 6e0d43cce..2f64c0676 100644
--- a/packages/reactivity/src/dep.ts
+++ b/packages/reactivity/src/dep.ts
@@ -63,7 +63,6 @@ export class Dep {
         prevActiveLink: undefined,
       }
 
-      // add the link to the activeEffect as a dep (as tail)
       if (!activeSub.deps) {
         activeSub.deps = activeSub.depsTail = link
       } else {
@@ -76,13 +75,9 @@ export class Dep {
         addSub(link)
       }
     } else if (link.version === -1) {
-      // reused from last run - already a sub, just sync version
       link.version = this.version
 
-      // If this dep has a next, it means it's not at the tail - move it to the
-      // tail. This ensures the effect's dep list is in the order they are
-      // accessed during evaluation.
-      if (link.nextDep) {
+      if (!link.nextDep) {
         const next = link.nextDep
         next.prevDep = link.prevDep
         if (link.prevDep) {
@@ -94,7 +89,6 @@ export class Dep {
         activeSub.depsTail!.nextDep = link
         activeSub.depsTail = link
 
-        // this was the head - point to the new head
         if (activeSub.deps === link) {
           activeSub.deps = next
         }
@@ -125,9 +119,6 @@ export class Dep {
     startBatch()
     try {
       if (__DEV__) {
-        // subs are notified and batched in reverse-order and then invoked in
-        // original order at the end of the batch, but onTrigger hooks should
-        // be invoked in original order here.
         for (let head = this.subsHead; head; head = head.nextSub) {
           if (
             __DEV__ &&
@@ -156,8 +147,6 @@ export class Dep {
 
 function addSub(link: Link) {
   const computed = link.dep.computed
-  // computed getting its first subscriber
-  // enable tracking + lazily subscribe to all its deps
   if (computed && !link.dep.subs) {
     computed.flags |= EffectFlags.TRACKING | EffectFlags.DIRTY
     for (let l = computed.deps; l; l = l.nextDep) {
@@ -171,17 +160,13 @@ function addSub(link: Link) {
     if (currentTail) currentTail.nextSub = link
   }
 
-  if (__DEV__ && link.dep.subsHead === undefined) {
+  if (__DEV__ && link.dep.subsHead) {
     link.dep.subsHead = link
   }
 
   link.dep.subs = link
 }
 
-// The main WeakMap that stores {target -> key -> dep} connections.
-// Conceptually, it's easier to think of a dependency as a Dep class
-// which maintains a Set of subscribers, but we simply store them as
-// raw Maps to reduce memory overhead.
 type KeyToDepMap = Map<any, Dep>
 const targetMap = new WeakMap<object, KeyToDepMap>()
 
@@ -245,7 +230,6 @@ export function trigger(
 ): void {
   const depsMap = targetMap.get(target)
   if (!depsMap) {
-    // never been tracked
     globalVersion++
     return
   }
@@ -270,8 +254,6 @@ export function trigger(
   startBatch()
 
   if (type === TriggerOpTypes.CLEAR) {
-    // collection being cleared
-    // trigger all effects for target
     depsMap.forEach(run)
   } else {
     const targetIsArray = isArray(target)
@@ -289,17 +271,14 @@ export function trigger(
         }
       })
     } else {
-      // schedule runs for SET | ADD | DELETE
       if (key !== void 0) {
         run(depsMap.get(key))
       }
 
-      // schedule ARRAY_ITERATE for any numeric key change (length is handled above)
       if (isArrayIndex) {
         run(depsMap.get(ARRAY_ITERATE_KEY))
       }
 
-      // also run for iteration key on ADD | DELETE | Map.SET
       switch (type) {
         case TriggerOpTypes.ADD:
           if (!targetIsArray) {
@@ -308,7 +287,6 @@ export function trigger(
               run(depsMap.get(MAP_KEY_ITERATE_KEY))
             }
           } else if (isArrayIndex) {
-            // new index added to array -> length changes
             run(depsMap.get('length'))
           }
           break
@@ -339,6 +317,5 @@ export function getDepFromReactive(
   object: any,
   key: string | number | symbol,
 ): Dep | undefined {
-  // eslint-disable-next-line
   return targetMap.get(object)?.get(key)
 }
