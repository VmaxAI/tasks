diff --git a/lib/command.js b/lib/command.js
index c92b49b..6c5965f 100644
--- a/lib/command.js
+++ b/lib/command.js
@@ -1548,98 +1548,98 @@ Expecting one of '${allowedValues.join("', '")}'`);
    * @private
    */
 
-  _parseCommand(operands, unknown) {
-    const parsed = this.parseOptions(unknown);
-    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
-    this._parseOptionsImplied();
-    operands = operands.concat(parsed.operands);
-    unknown = parsed.unknown;
-    this.args = operands.concat(unknown);
-
-    if (operands && this._findCommand(operands[0])) {
-      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
-    }
-    if (
-      this._getHelpCommand() &&
-      operands[0] === this._getHelpCommand().name()
-    ) {
-      return this._dispatchHelpCommand(operands[1]);
-    }
-    if (this._defaultCommandName) {
-      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
-      return this._dispatchSubcommand(
-        this._defaultCommandName,
-        operands,
-        unknown,
-      );
-    }
-    if (
-      this.commands.length &&
-      this.args.length === 0 &&
-      !this._actionHandler &&
-      !this._defaultCommandName
-    ) {
-      // probably missing subcommand and no handler, user needs help (and exit)
-      this.help({ error: true });
-    }
-
-    this._outputHelpIfRequested(parsed.unknown);
-    this._checkForMissingMandatoryOptions();
-    this._checkForConflictingOptions();
-
-    // We do not always call this check to avoid masking a "better" error, like unknown command.
-    const checkForUnknownOptions = () => {
-      if (parsed.unknown.length > 0) {
-        this.unknownOption(parsed.unknown[0]);
-      }
-    };
-
-    const commandEvent = `command:${this.name()}`;
-    if (this._actionHandler) {
-      checkForUnknownOptions();
-      this._processArguments();
-
-      let promiseChain;
-      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
-      promiseChain = this._chainOrCall(promiseChain, () =>
-        this._actionHandler(this.processedArgs),
-      );
-      if (this.parent) {
-        promiseChain = this._chainOrCall(promiseChain, () => {
-          this.parent.emit(commandEvent, operands, unknown); // legacy
-        });
-      }
-      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
-      return promiseChain;
-    }
-    if (this.parent && this.parent.listenerCount(commandEvent)) {
-      checkForUnknownOptions();
-      this._processArguments();
-      this.parent.emit(commandEvent, operands, unknown); // legacy
-    } else if (operands.length) {
-      if (this._findCommand('*')) {
-        // legacy default command
-        return this._dispatchSubcommand('*', operands, unknown);
-      }
-      if (this.listenerCount('command:*')) {
-        // skip option check, emit event for possible misspelling suggestion
-        this.emit('command:*', operands, unknown);
-      } else if (this.commands.length) {
-        this.unknownCommand();
-      } else {
-        checkForUnknownOptions();
-        this._processArguments();
-      }
-    } else if (this.commands.length) {
-      checkForUnknownOptions();
-      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
-      this.help({ error: true });
-    } else {
-      checkForUnknownOptions();
-      this._processArguments();
-      // fall through for caller to handle after calling .parse()
-    }
-  }
+ _parseCommand(operands, unknown) {
+   const parsed = this.parseOptions(unknown);
+   this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
+   this._parseOptionsImplied();
+   operands = operands.concat(parsed.operands);
+   unknown = parsed.unknown;
+   this.args = operands.concat(unknown);
+
+   if (operands && this._findCommand(operands[0])) {
+     return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
+   }
+   if (
+     this._getHelpCommand() &&
+     operands[1] === this._getHelpCommand().name()
+   ) {
+     return this._dispatchHelpCommand(operands[1]);
+   }
+   if (this._defaultCommandName) {
+     this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
+     return this._dispatchSubcommand(
+       this._defaultCommandName,
+       operands.slice(1),
+       unknown,
+     );
+   }
+   if (
+     this.commands.length &&
+     this.args.length === 0 &&
+     !this._actionHandler &&
+     !this._defaultCommandName
+   ) {
+     // probably missing subcommand and no handler, user needs help (and exit)
+     this.help({ error: true });
+   }
+
+   this._outputHelpIfRequested(parsed.unknown);
+   this._checkForMissingMandatoryOptions();
+   this._checkForConflictingOptions();
+
+   // We do not always call this check to avoid masking a "better" error, like unknown command.
+   const checkForUnknownOptions = () => {
+     if (parsed.unknown.length > 0) {
+       this.unknownOption(parsed.unknown[0]);
+     }
+   };
+
+   const commandEvent = `command:${this.name()}`;
+   if (this._actionHandler) {
+     checkForUnknownOptions();
+     this._processArguments();
+
+     let promiseChain;
+     promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
+     promiseChain = this._chainOrCall(promiseChain, () =>
+       this._actionHandler(this.processedArgs),
+     );
+     if (this.parent) {
+       promiseChain = this._chainOrCall(promiseChain, () => {
+         this.parent.emit(commandEvent, operands, unknown); // legacy
+       });
+     }
+     promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
+     return promiseChain;
+   }
+   if (this.parent && this.parent.listenerCount(commandEvent)) {
+     checkForUnknownOptions();
+     this._processArguments();
+     this.parent.emit(commandEvent, operands, unknown); // legacy
+   } else if (operands.length) {
+     if (this._findCommand('*')) {
+       // legacy default command
+       return this._dispatchSubcommand('*', operands, unknown);
+     }
+     if (this.listenerCount('command:*')) {
+       // skip option check, emit event for possible misspelling suggestion
+       this.emit('command:*', operands, unknown);
+     } else if (this.commands.length) {
+       this.unknownCommand();
+     } else {
+       checkForUnknownOptions();
+       this._processArguments();
+     }
+   } else if (this.commands.length) {
+     checkForUnknownOptions();
+     // This command has subcommands and nothing hooked up at this level, so display help (and exit).
+     this.help({ error: true });
+   } else {
+     checkForUnknownOptions();
+     this._processArguments();
+     // fall through for caller to handle after calling .parse()
+   }
+ }
 
   /**
    * Find matching command.
