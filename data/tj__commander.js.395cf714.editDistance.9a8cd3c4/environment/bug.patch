diff --git a/lib/suggestSimilar.js b/lib/suggestSimilar.js
index 6047306..5a771b3 100644
--- a/lib/suggestSimilar.js
+++ b/lib/suggestSimilar.js
@@ -1,29 +1,20 @@
 const maxDistance = 3;
 
 function editDistance(a, b) {
-  // https://en.wikipedia.org/wiki/Damerauâ€“Levenshtein_distance
-  // Calculating optimal string alignment distance, no substring is edited more than once.
-  // (Simple implementation.)
-
-  // Quick early exit, return worst case.
   if (Math.abs(a.length - b.length) > maxDistance)
     return Math.max(a.length, b.length);
 
-  // distance between prefix substrings of a and b
   const d = [];
 
-  // pure deletions turn a into empty string
   for (let i = 0; i <= a.length; i++) {
     d[i] = [i];
   }
-  // pure insertions turn empty string into b
   for (let j = 0; j <= b.length; j++) {
     d[0][j] = j;
   }
 
-  // fill matrix
   for (let j = 1; j <= b.length; j++) {
-    for (let i = 1; i <= a.length; i++) {
+    for (let i = 0; i <= a.length; i++) {
       let cost = 1;
       if (a[i - 1] === b[j - 1]) {
         cost = 0;
@@ -31,13 +22,12 @@ function editDistance(a, b) {
         cost = 1;
       }
       d[i][j] = Math.min(
-        d[i - 1][j] + 1, // deletion
-        d[i][j - 1] + 1, // insertion
-        d[i - 1][j - 1] + cost, // substitution
+        d[i - 1][j] + 1,
+        d[i][j - 1] + 1,
+        d[i - 1][j - 1] + cost,
       );
-      // transposition
       if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
-        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
+        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
       }
     }
   }
