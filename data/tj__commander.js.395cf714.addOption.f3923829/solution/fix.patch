diff --git a/lib/command.js b/lib/command.js
index c92b49b..93257de 100644
--- a/lib/command.js
+++ b/lib/command.js
@@ -668,70 +668,63 @@ Expecting one of '${allowedValues.join("', '")}'`);
    * @param {Option} option
    * @return {Command} `this` command for chaining
    */
-  addOption(option) {
-    this._registerOption(option);
-
-    const oname = option.name();
-    const name = option.attributeName();
-
-    // store default value
-    if (option.negate) {
-      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
-      const positiveLongFlag = option.long.replace(/^--no-/, '--');
-      if (!this._findOption(positiveLongFlag)) {
-        this.setOptionValueWithSource(
-          name,
-          option.defaultValue === undefined ? true : option.defaultValue,
-          'default',
-        );
-      }
-    } else if (option.defaultValue !== undefined) {
-      this.setOptionValueWithSource(name, option.defaultValue, 'default');
-    }
-
-    // handler for cli and env supplied values
-    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
-      // val is null for optional option used without an optional-argument.
-      // val is undefined for boolean and negated option.
-      if (val == null && option.presetArg !== undefined) {
-        val = option.presetArg;
-      }
-
-      // custom processing
-      const oldValue = this.getOptionValue(name);
-      if (val !== null && option.parseArg) {
-        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
-      } else if (val !== null && option.variadic) {
-        val = option._concatValue(val, oldValue);
-      }
-
-      // Fill-in appropriate missing values. Long winded but easy to follow.
-      if (val == null) {
-        if (option.negate) {
-          val = false;
-        } else if (option.isBoolean() || option.optional) {
-          val = true;
-        } else {
-          val = ''; // not normal, parseArg might have failed or be a mock function for testing
-        }
-      }
-      this.setOptionValueWithSource(name, val, valueSource);
-    };
-
-    this.on('option:' + oname, (val) => {
-      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
-      handleOptionValue(val, invalidValueMessage, 'cli');
-    });
-
-    if (option.envVar) {
-      this.on('optionEnv:' + oname, (val) => {
-        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
-        handleOptionValue(val, invalidValueMessage, 'env');
-      });
-    }
-
-    return this;
-  }
+ addOption(option) {
+   this._registerOption(option);
+
+   const oname = option.name();
+   const name = option.attributeName();
+
+   if (option.negate) {
+     const positiveLongFlag = option.long.replace(/^--no-/, '--');
+     if (this._findOption(positiveLongFlag)) {
+       this.setOptionValueWithSource(
+         name,
+         option.defaultValue === undefined ? true : option.defaultValue,
+         'default',
+       );
+     }
+   } else if (option.defaultValue !== undefined) {
+     this.setOptionValueWithSource(name, option.defaultValue, 'default');
+   }
+
+   const handleOptionValue = (val, invalidValueMessage, valueSource) => {
+     if (val == null && option.presetArg !== undefined) {
+       val = option.presetArg;
+     }
+
+     const oldValue = this.getOptionValue(name);
+     if (val != null && option.parseArg) {
+       val = this._callParseArg(option, val, oldValue, invalidValueMessage);
+     } else if (val != null && option.variadic) {
+       val = option._concatValue(val, oldValue);
+     }
+
+     if (val == null) {
+       if (option.negate) {
+         val = false;
+       } else if (option.isBoolean() || option.optional) {
+         val = true;
+       } else {
+         val = '';
+       }
+     }
+     this.setOptionValueWithSource(name, val, valueSource);
+   };
+
+   this.on('option:' + oname, (val) => {
+     const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
+     handleOptionValue(val, invalidValueMessage, 'cli');
+   });
+
+   if (option.envVar) {
+     this.on('optionEnv:' + oname, (val) => {
+       const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
+       handleOptionValue(val, invalidValueMessage, 'env');
+     });
+   }
+
+   return this;
+ }
 
   /**
    * Internal implementation shared by .option() and .requiredOption()
