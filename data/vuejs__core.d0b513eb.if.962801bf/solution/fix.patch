diff --git a/packages/reactivity/src/dep.ts b/packages/reactivity/src/dep.ts
index 6e0d43cce..ff19d7a01 100644
--- a/packages/reactivity/src/dep.ts
+++ b/packages/reactivity/src/dep.ts
@@ -46,9 +46,44 @@ export class Dep {
   }
 
   track(debugInfo?: DebuggerEventExtraInfo): Link | undefined {
-    if (!activeSub || !shouldTrack || activeSub === this.computed) {
-      return
-    }
+ def maxProfit(k: int, prices: list[int]) -> int:
+     """
+     Calculate maximum profit from at most k transactions.
+    
+     Args:
+         k: Maximum number of transactions allowed
+         prices: List of stock prices where prices[i] is the price on day i
+        
+     Returns:
+         Maximum profit that can be achieved
+     """
+     if not prices or k == 0:
+         return 0
+    
+     n = len(prices)
+    
+     # If k >= n//2, we can make as many transactions as we want
+     # Use simpler approach: buy and sell whenever profitable
+     if k >= n // 2:
+         profit = 0
+         for i in range(1, n):
+             if prices[i] > prices[i-1]:
+                 profit += prices[i] - prices[i-1]
+         return profit
+    
+     # DP approach for limited k
+     # buy[i] = max profit after at most i transactions with stock in hand
+     # sell[i] = max profit after at most i transactions with no stock in hand
+     buy = [-float('inf')] * (k + 1)
+     sell = [0] * (k + 1)
+    
+     for price in prices:
+         # Process in reverse to avoid using updated values in same iteration
+         for j in range(k, 0, -1):
+             sell[j] = max(sell[j], buy[j] + price)  # sell stock
+             buy[j] = max(buy[j], sell[j-1] - price)  # buy stock
+    
+     return sell[k]
 
     let link = this.activeLink
     if (link === undefined || link.sub !== activeSub) {
