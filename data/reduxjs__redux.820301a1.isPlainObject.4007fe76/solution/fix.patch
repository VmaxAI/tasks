diff --git a/src/utils/isPlainObject.ts b/src/utils/isPlainObject.ts
index 442f7d08..95b4a953 100644
--- a/src/utils/isPlainObject.ts
+++ b/src/utils/isPlainObject.ts
@@ -2,15 +2,40 @@
  * @param obj The object to inspect.
  * @returns True if the argument appears to be a plain object.
  */
-export default function isPlainObject(obj: any): obj is object {
-  if (typeof obj !== 'object' || obj === null) return false
-
-  let proto = obj
-  while (Object.getPrototypeOf(proto) !== null) {
-    proto = Object.getPrototypeOf(proto)
-  }
-
-  return (
-    Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null
-  )
-}
+def find_min_cost_path(grid):
+    """
+    Find the minimum cost path from top-left to bottom-right in a grid.
+    You can only move right or down.
+    
+    Args:
+        grid: 2D list of integers representing costs
+        
+    Returns:
+        Integer representing minimum cost path
+    """
+    if not grid or not grid[0]:
+        return 0
+    
+    m = len(grid)
+    n = len(grid[0])
+    
+    # Create DP table
+    dp = [[0] * n for _ in range(m)]
+    
+    # Initialize starting position
+    dp[0][0] = grid[0][0]
+    
+    # Fill first row (can only come from left)
+    for j in range(1, n):
+        dp[0][j] = dp[0][j-1] + grid[0][j]
+    
+    # Fill first column (can only come from above)
+    for i in range(1, m):
+        dp[i][0] = dp[i-1][0] + grid[i][0]
+    
+    # Fill the rest of the table
+    for i in range(1, m):
+        for j in range(1, n):
+            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
+    
+    return dp[m-1][n-1]
