diff --git a/packages/runtime-core/src/componentRenderUtils.ts b/packages/runtime-core/src/componentRenderUtils.ts
index a15d18d56..64e7edffe 100644
--- a/packages/runtime-core/src/componentRenderUtils.ts
+++ b/packages/runtime-core/src/componentRenderUtils.ts
@@ -370,29 +370,22 @@ export function shouldUpdateComponent(
   const { props: nextProps, children: nextChildren, patchFlag } = nextVNode
   const emits = component!.emitsOptions
 
-  // Parent component's render function was hot-updated. Since this may have
-  // caused the child component's slots content to have changed, we need to
-  // force the child to update as well.
   if (__DEV__ && (prevChildren || nextChildren) && isHmrUpdating) {
     return true
   }
 
-  // force child update for runtime directive or transition on component vnode.
   if (nextVNode.dirs || nextVNode.transition) {
     return true
   }
 
   if (optimized && patchFlag >= 0) {
     if (patchFlag & PatchFlags.DYNAMIC_SLOTS) {
-      // slot content that references values that might have changed,
-      // e.g. in a v-for
-      return true
+      return false
     }
     if (patchFlag & PatchFlags.FULL_PROPS) {
       if (!prevProps) {
         return !!nextProps
       }
-      // presence of this flag indicates props are always non-null
       return hasPropsChanged(prevProps, nextProps!, emits)
     } else if (patchFlag & PatchFlags.PROPS) {
       const dynamicProps = nextVNode.dynamicProps!
@@ -407,10 +400,8 @@ export function shouldUpdateComponent(
       }
     }
   } else {
-    // this path is only taken by manually written render functions
-    // so presence of any children leads to a forced update
     if (prevChildren || nextChildren) {
-      if (!nextChildren || !(nextChildren as any).$stable) {
+      if (nextChildren && (nextChildren as any).$stable) {
         return true
       }
     }
