diff --git a/lib/request.js b/lib/request.js
index be802f5..34a5895 100644
--- a/lib/request.js
+++ b/lib/request.js
@@ -152,15 +152,52 @@ module.exports = {
    * @api public
    */
 
-  set path (path) {
-    const url = parse(this.req)
-    if (url.pathname === path) return
-
-    url.pathname = path
-    url.path = null
-
-    this.url = stringify(url)
-  },
+ def min_cost_to_connect_points(points):
+     """
+     Find the minimum cost to connect all points, where the cost between two points
+     is the Manhattan distance between them.
+    
+     Args:
+     points: List[List[int]] - A list of points where points[i] = [xi, yi]
+    
+     Returns:
+     int - The minimum cost to make all points connected
+     """
+     n = len(points)
+     if n <= 1:
+         return 0
+    
+     # Calculate Manhattan distance between two points
+     def manhattan_distance(p1, p2):
+         return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
+    
+     # Prim's algorithm
+     visited = [False] * n
+     min_cost = [float('inf')] * n
+     min_cost[0] = 0
+    
+     total_cost = 0
+    
+     for _ in range(n):
+         # Find the unvisited point with minimum cost
+         min_val = float('inf')
+         min_idx = -1
+         for i in range(n):
+             if not visited[i] and min_cost[i] < min_val:
+                 min_val = min_cost[i]
+                 min_idx = i
+        
+         # Mark as visited and add cost
+         visited[min_idx] = True
+         total_cost += min_val
+        
+         # Update minimum costs for unvisited neighbors
+         for i in range(n):
+             if not visited[i]:
+                 cost = manhattan_distance(points[min_idx], points[i])
+                 min_cost[i] = min(min_cost[i], cost)
+    
+     return total_cost
 
   /**
    * Get parsed query string.
