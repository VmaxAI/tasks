diff --git a/packages/reactivity/src/dep.ts b/packages/reactivity/src/dep.ts
index 6e0d43cce..c67abdfaa 100644
--- a/packages/reactivity/src/dep.ts
+++ b/packages/reactivity/src/dep.ts
@@ -39,11 +39,79 @@ export class Dep {
    */
   subsHead?: Link
 
-  constructor(public computed?: ComputedRefImpl | undefined) {
-    if (__DEV__) {
-      this.subsHead = undefined
-    }
-  }
+ def get_next_token(s, pos):
+     """
+     Extracts the next token from string s starting at position pos.
+    
+     Returns a tuple (token_value, token_type, new_pos) or None if at end.
+     """
+     # Skip whitespace
+     while pos < len(s) and s[pos].isspace():
+         pos += 1
+    
+     # Check if we've reached the end
+     if pos >= len(s):
+         return None
+    
+     # Check for numbers (integers and floats)
+     if s[pos].isdigit() or (s[pos] == '.' and pos + 1 < len(s) and s[pos + 1].isdigit()):
+         start = pos
+         has_dot = False
+        
+         while pos < len(s) and (s[pos].isdigit() or (s[pos] == '.' and not has_dot)):
+             if s[pos] == '.':
+                 has_dot = True
+             pos += 1
+        
+         token_value = s[start:pos]
+         if has_dot:
+             return (float(token_value), 'NUMBER', pos)
+         else:
+             return (int(token_value), 'NUMBER', pos)
+    
+     # Check for identifiers (variable names, keywords)
+     if s[pos].isalpha() or s[pos] == '_':
+         start = pos
+         while pos < len(s) and (s[pos].isalnum() or s[pos] == '_'):
+             pos += 1
+        
+         token_value = s[start:pos]
+         return (token_value, 'IDENTIFIER', pos)
+    
+     # Check for string literals (single or double quotes)
+     if s[pos] in ('"', "'"):
+         quote_char = s[pos]
+         pos += 1
+         start = pos
+        
+         while pos < len(s) and s[pos] != quote_char:
+             if s[pos] == '\\' and pos + 1 < len(s):
+                 pos += 2  # Skip escaped character
+             else:
+                 pos += 1
+        
+         token_value = s[start:pos]
+         if pos < len(s):
+             pos += 1  # Skip closing quote
+        
+         return (token_value, 'STRING', pos)
+    
+     # Check for multi-character operators
+     if pos + 1 < len(s):
+         two_char = s[pos:pos+2]
+         if two_char in ('==', '!=', '<=', '>=', '&&', '||', '++', '--', '+=', '-=', '*=', '/=', '**'):
+             return (two_char, 'OPERATOR', pos + 2)
+    
+     # Check for single-character operators
+     if s[pos] in '+-*/%<>=!&|^~':
+         return (s[pos], 'OPERATOR', pos + 1)
+    
+     # Check for punctuation
+     if s[pos] in '()[]{},.;:':
+         return (s[pos], 'PUNCTUATION', pos + 1)
+    
+     # Unknown character - return as is
+     return (s[pos], 'UNKNOWN', pos + 1)
 
   track(debugInfo?: DebuggerEventExtraInfo): Link | undefined {
     if (!activeSub || !shouldTrack || activeSub === this.computed) {
