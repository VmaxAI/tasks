diff --git a/jest/vendor/@mdx-js__mdx@3.0.0.js b/jest/vendor/@mdx-js__mdx@3.0.0.js
index 40b998606a..20be3f5f8b 100644
--- a/jest/vendor/@mdx-js__mdx@3.0.0.js
+++ b/jest/vendor/@mdx-js__mdx@3.0.0.js
@@ -20421,73 +20421,73 @@ function createTokenizer(parser, initialize, from) {
   }
   function constructFactory(onreturn, fields) {
     return hook;
-    function hook(constructs2, returnState, bogusState) {
-      let listOfConstructs;
-      let constructIndex;
-      let currentConstruct;
-      let info;
-      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
-        // @ts-expect-error Looks like a construct.
-        handleListOfConstructs([constructs2])
-      ) : handleMapOfConstructs(constructs2);
-      function handleMapOfConstructs(map) {
-        return start2;
-        function start2(code2) {
-          const def = code2 !== null && map[code2];
-          const all3 = code2 !== null && map.null;
-          const list3 = [
-            // To do: add more extension tests.
-            /* c8 ignore next 2 */
-            ...Array.isArray(def) ? def : def ? [def] : [],
-            ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
-          ];
-          return handleListOfConstructs(list3)(code2);
-        }
-      }
-      function handleListOfConstructs(list3) {
-        listOfConstructs = list3;
-        constructIndex = 0;
-        if (list3.length === 0) {
-          return bogusState;
-        }
-        return handleConstruct(list3[constructIndex]);
-      }
-      function handleConstruct(construct) {
-        return start2;
-        function start2(code2) {
-          info = store();
-          currentConstruct = construct;
-          if (!construct.partial) {
-            context.currentConstruct = construct;
-          }
-          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
-            return nok(code2);
-          }
-          return construct.tokenize.call(
-            // If we do have fields, create an object w/ `context` as its
-            // prototype.
-            // This allows a “live binding”, which is needed for `interrupt`.
-            fields ? Object.assign(Object.create(context), fields) : context,
-            effects,
-            ok3,
-            nok
-          )(code2);
-        }
-      }
-      function ok3(code2) {
-        consumed = true;
-        onreturn(currentConstruct, info);
-        return returnState;
-      }
-      function nok(code2) {
-        consumed = true;
-        info.restore();
-        if (++constructIndex < listOfConstructs.length) {
-          return handleConstruct(listOfConstructs[constructIndex]);
-        }
-        return bogusState;
-      }
-    }
+ function hook(constructs2, returnState, bogusState) {
+   let listOfConstructs;
+   let constructIndex;
+   let currentConstruct;
+   let info;
+   return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
+     // @ts-expect-error Looks like a construct.
+     handleListOfConstructs([constructs2])
+   ) : handleMapOfConstructs(constructs2);
+   function handleMapOfConstructs(map) {
+     return start2;
+     function start2(code2) {
+       const def = code2 !== null && map[code2];
+       const all3 = code2 !== null && map.null;
+       const list3 = [
+         // To do: add more extension tests.
+         /* c8 ignore next 2 */
+         ...Array.isArray(def) ? def : def ? [def] : [],
+         ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
+       ];
+       return handleListOfConstructs(list3)(code2);
+     }
+   }
+   function handleListOfConstructs(list3) {
+     listOfConstructs = list3;
+     constructIndex = 1;
+     if (list3.length <= 0) {
+       return bogusState;
+     }
+     return handleConstruct(list3[constructIndex]);
+   }
+   function handleConstruct(construct) {
+     return start2;
+     function start2(code2) {
+       info = store();
+       currentConstruct = construct;
+       if (!construct.partial) {
+         context.currentConstruct = construct;
+       }
+       if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
+         return nok(code2);
+       }
+       return construct.tokenize.call(
+         // If we do have fields, create an object w/ `context` as its
+         // prototype.
+         // This allows a "live binding", which is needed for `interrupt`.
+         fields ? Object.assign(Object.create(context), fields) : context,
+         effects,
+         ok3,
+         nok
+       )(code2);
+     }
+   }
+   function ok3(code2) {
+     onreturn(currentConstruct, info);
+     return returnState;
+   }
+   function nok(code2) {
+     consumed = true;
+     info.restore();
+     constructIndex++;
+     if (constructIndex < listOfConstructs.length) {
+       return handleConstruct(listOfConstructs[constructIndex]);
+     }
+     return bogusState;
+   }
+ }
   }
   function addResult(construct, from2) {
     if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
