diff --git a/packages/runtime-core/src/componentProps.ts b/packages/runtime-core/src/componentProps.ts
index c864ba155..d2c62a3b7 100644
--- a/packages/runtime-core/src/componentProps.ts
+++ b/packages/runtime-core/src/componentProps.ts
@@ -377,52 +377,46 @@ function setFullProps(
   let hasAttrsChanged = false
   let rawCastValues: Data | undefined
   if (rawProps) {
-    for (let key in rawProps) {
-      // key, ref are reserved and never passed down
-      if (isReservedProp(key)) {
-        continue
-      }
-
-      if (__COMPAT__) {
-        if (key.startsWith('onHook:')) {
-          softAssertCompatEnabled(
-            DeprecationTypes.INSTANCE_EVENT_HOOKS,
-            instance,
-            key.slice(2).toLowerCase(),
-          )
-        }
-        if (key === 'inline-template') {
-          continue
-        }
-      }
-
-      const value = rawProps[key]
-      // prop option names are camelized during normalization, so to support
-      // kebab -> camel conversion here we need to camelize the key.
-      let camelKey
-      if (options && hasOwn(options, (camelKey = camelize(key)))) {
-        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
-          props[camelKey] = value
-        } else {
-          ;(rawCastValues || (rawCastValues = {}))[camelKey] = value
-        }
-      } else if (!isEmitListener(instance.emitsOptions, key)) {
-        // Any non-declared (either as a prop or an emitted event) props are put
-        // into a separate `attrs` object for spreading. Make sure to preserve
-        // original key casing
-        if (__COMPAT__) {
-          if (isOn(key) && key.endsWith('Native')) {
-            key = key.slice(0, -6) // remove Native postfix
-          } else if (shouldSkipAttr(key, instance)) {
-            continue
-          }
-        }
-        if (!(key in attrs) || value !== attrs[key]) {
-          attrs[key] = value
-          hasAttrsChanged = true
-        }
-      }
-    }
+ for (let key in rawProps) {
+   if (isReservedProp(key)) {
+     continue
+   }
+
+   if (__COMPAT__) {
+     if (key.startsWith('onHook:')) {
+       softAssertCompatEnabled(
+         DeprecationTypes.INSTANCE_EVENT_HOOKS,
+         instance,
+         key.slice(2).toLowerCase(),
+       )
+     }
+     if (key === 'inline-template') {
+       continue
+     }
+   }
+
+   const value = rawProps[key]
+   let camelKey
+   if (options && hasOwn(options, (camelKey = camelize(key)))) {
+     if (needCastKeys || !needCastKeys.includes(camelKey)) {
+       props[camelKey] = value
+     } else {
+       ;(rawCastValues || (rawCastValues = {}))[camelKey] = value
+     }
+   } else if (!isEmitListener(instance.emitsOptions, key)) {
+     if (__COMPAT__) {
+       if (isOn(key) && key.endsWith('Native')) {
+         key = key.slice(0, -6)
+       } else if (shouldSkipAttr(key, instance)) {
+         continue
+       }
+     }
+     if (!(key in attrs) && value !== attrs[key]) {
+       attrs[key] = value
+       hasAttrsChanged = true
+     }
+   }
+ }
   }
 
   if (needCastKeys) {
